<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>AltErgoLib__Typed (alt-ergo-lib.AltErgoLib__Typed)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">alt-ergo-lib</a> &#x00BB; AltErgoLib__Typed</nav><h1>Module <code>AltErgoLib__Typed</code></h1><p>Typed AST</p><p>This module defines a typed AST, used to represent typed terms before they are hashconsed.</p><nav class="toc"><ul><li><a href="#annotations">Annotations</a></li><li><a href="#terms-and-formulas">Terms and formulas</a></li><li><a href="#declarations">Declarations</a><ul><li><a href="#printing">Printing</a></li></ul></li></ul></nav></header><section><header><h3 id="annotations"><a href="#annotations" class="anchor"></a>Annotations</h3></header><dl><dt class="spec type" id="type-annoted"><a href="#type-annoted" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) annoted</span></code><code> = </code><code>{</code><table class="record"><tr id="type-annoted.c" class="anchored"><td class="def field"><a href="#type-annoted.c" class="anchor"></a><code>c : <span class="type-var">'a</span>;</code></td></tr><tr id="type-annoted.annot" class="anchored"><td class="def field"><a href="#type-annoted.annot" class="anchor"></a><code>annot : <span class="type-var">'b</span>;</code></td></tr></table><code>}</code></dt><dd><p>An annoted structure. Usually used to annotate terms.</p></dd></dl><dl><dt class="spec value" id="val-new_id"><a href="#val-new_id" class="anchor"></a><code><span class="keyword">val</span> new_id : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Generate a new, fresh integer (useful for annotations).</p></dd></dl><dl><dt class="spec value" id="val-mk"><a href="#val-mk" class="anchor"></a><code><span class="keyword">val</span> mk : <span>?&#8288;annot:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, int)</span> <a href="index.html#type-annoted">annoted</a></span></code></dt><dd><p>Create an annoted value with the given annotation. If no annotation is given, a fresh annotation is generated using <a href="index.html#val-new_id"><code>new_id</code></a>.</p></dd></dl></section><section><header><h3 id="terms-and-formulas"><a href="#terms-and-formulas" class="anchor"></a>Terms and formulas</h3></header><dl><dt class="spec type" id="type-tconstant"><a href="#type-tconstant" class="anchor"></a><code><span class="keyword">type</span> tconstant</code><code> = </code><table class="variant"><tr id="type-tconstant.Tint" class="anchored"><td class="def constructor"><a href="#type-tconstant.Tint" class="anchor"></a><code>| </code><code><span class="constructor">Tint</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>An integer constant.</p></td></tr><tr id="type-tconstant.Treal" class="anchored"><td class="def constructor"><a href="#type-tconstant.Treal" class="anchor"></a><code>| </code><code><span class="constructor">Treal</span> <span class="keyword">of</span> Num.num</code></td><td class="doc"><p>Real constant.</p></td></tr><tr id="type-tconstant.Tbitv" class="anchored"><td class="def constructor"><a href="#type-tconstant.Tbitv" class="anchor"></a><code>| </code><code><span class="constructor">Tbitv</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Bitvector constant.</p></td></tr><tr id="type-tconstant.Ttrue" class="anchored"><td class="def constructor"><a href="#type-tconstant.Ttrue" class="anchor"></a><code>| </code><code><span class="constructor">Ttrue</span></code></td><td class="doc"><p>The true boolean (or proposition ?)</p></td></tr><tr id="type-tconstant.Tfalse" class="anchored"><td class="def constructor"><a href="#type-tconstant.Tfalse" class="anchor"></a><code>| </code><code><span class="constructor">Tfalse</span></code></td><td class="doc"><p>The false boolean</p></td></tr><tr id="type-tconstant.Tvoid" class="anchored"><td class="def constructor"><a href="#type-tconstant.Tvoid" class="anchor"></a><code>| </code><code><span class="constructor">Tvoid</span></code></td><td class="doc"><p>The only value of type unit</p></td></tr></table></dt><dd><p>Typed constants.</p></dd></dl><dl><dt class="spec type" id="type-oplogic"><a href="#type-oplogic" class="anchor"></a><code><span class="keyword">type</span> oplogic</code><code> = </code><table class="variant"><tr id="type-oplogic.OPand" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPand" class="anchor"></a><code>| </code><code><span class="constructor">OPand</span></code></td><td class="doc"><p>conjunction</p></td></tr><tr id="type-oplogic.OPor" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPor" class="anchor"></a><code>| </code><code><span class="constructor">OPor</span></code></td><td class="doc"><p>disjunction</p></td></tr><tr id="type-oplogic.OPxor" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPxor" class="anchor"></a><code>| </code><code><span class="constructor">OPxor</span></code></td><td class="doc"><p>exclusive disjunction</p></td></tr><tr id="type-oplogic.OPimp" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPimp" class="anchor"></a><code>| </code><code><span class="constructor">OPimp</span></code></td><td class="doc"><p>implication</p></td></tr><tr id="type-oplogic.OPnot" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPnot" class="anchor"></a><code>| </code><code><span class="constructor">OPnot</span></code></td><td class="doc"><p>negation</p></td></tr><tr id="type-oplogic.OPiff" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPiff" class="anchor"></a><code>| </code><code><span class="constructor">OPiff</span></code></td><td class="doc"><p>equivalence</p></td></tr><tr id="type-oplogic.OPif" class="anchored"><td class="def constructor"><a href="#type-oplogic.OPif" class="anchor"></a><code>| </code><code><span class="constructor">OPif</span></code></td><td class="doc"><p>conditional branching</p></td></tr></table></dt><dd><p>Logic operators.</p></dd></dl><dl><dt class="spec type" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span class="keyword">type</span> pattern</code><code> = </code><table class="variant"><tr id="type-pattern.Constr" class="anchored"><td class="def constructor"><a href="#type-pattern.Constr" class="anchor"></a><code>| </code><code><span class="constructor">Constr</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-pattern.name" class="anchored"><td class="def field"><a href="#type-pattern.name" class="anchor"></a><code>name : <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a>;</code></td></tr><tr id="type-pattern.args" class="anchored"><td class="def field"><a href="#type-pattern.args" class="anchor"></a><code>args : <span><span>(<a href="../AltErgoLib/Var/index.html#type-t">AltErgoLib.Var.t</a> * <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span>;</code></td></tr></table><code>}</code></td></tr><tr id="type-pattern.Var" class="anchored"><td class="def constructor"><a href="#type-pattern.Var" class="anchor"></a><code>| </code><code><span class="constructor">Var</span> <span class="keyword">of</span> <a href="../AltErgoLib/Var/index.html#type-t">AltErgoLib.Var.t</a></code></td></tr></table></dt><dt class="spec type" id="type-tterm"><a href="#type-tterm" class="anchor"></a><code><span class="keyword">type</span> <span>'a tterm</span></code><code> = </code><code>{</code><table class="record"><tr id="type-tterm.tt_ty" class="anchored"><td class="def field"><a href="#type-tterm.tt_ty" class="anchor"></a><code>tt_ty : <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>;</code></td><td class="doc"><p>type of the term</p></td></tr><tr id="type-tterm.tt_desc" class="anchored"><td class="def field"><a href="#type-tterm.tt_desc" class="anchor"></a><code>tt_desc : <span><span class="type-var">'a</span> <a href="index.html#type-tt_desc">tt_desc</a></span>;</code></td><td class="doc"><p>term descriptor</p></td></tr></table><code>}</code></dt><dd><p>Typed terms. Polymorphic in the annotation: an <code>'a tterm</code> is a term annoted with values of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-atterm"><a href="#type-atterm" class="anchor"></a><code><span class="keyword">and</span> <span>'a atterm</span></code><code> = <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-tterm">tterm</a></span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-annoted">annoted</a></span></code></dt><dd><p>type alias for annoted typed terms.</p></dd></dl><dl><dt class="spec type" id="type-tt_desc"><a href="#type-tt_desc" class="anchor"></a><code><span class="keyword">and</span> <span>'a tt_desc</span></code><code> = </code><table class="variant"><tr id="type-tt_desc.TTconst" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTconst" class="anchor"></a><code>| </code><code><span class="constructor">TTconst</span> <span class="keyword">of</span> <a href="index.html#type-tconstant">tconstant</a></code></td><td class="doc"><p>Term constant</p></td></tr><tr id="type-tt_desc.TTvar" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTvar" class="anchor"></a><code>| </code><code><span class="constructor">TTvar</span> <span class="keyword">of</span> <a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a></code></td><td class="doc"><p>Term variables</p></td></tr><tr id="type-tt_desc.TTinfix" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTinfix" class="anchor"></a><code>| </code><code><span class="constructor">TTinfix</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Infix symbol application</p></td></tr><tr id="type-tt_desc.TTprefix" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTprefix" class="anchor"></a><code>| </code><code><span class="constructor">TTprefix</span> <span class="keyword">of</span> <a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Prefix symbol application</p></td></tr><tr id="type-tt_desc.TTapp" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTapp" class="anchor"></a><code>| </code><code><span class="constructor">TTapp</span> <span class="keyword">of</span> <a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span></code></td><td class="doc"><p>Arbitrary symbol application</p></td></tr><tr id="type-tt_desc.TTmapsTo" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTmapsTo" class="anchor"></a><code>| </code><code><span class="constructor">TTmapsTo</span> <span class="keyword">of</span> <a href="../AltErgoLib/Var/index.html#type-t">AltErgoLib.Var.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Used in semantic triggers for floating point arithmetic. See sources/preludes/fpa-theory-2017-01-04-16h00.ae</p></td></tr><tr id="type-tt_desc.TTinInterval" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTinInterval" class="anchor"></a><code>| </code><code><span class="constructor">TTinInterval</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <a href="../AltErgoLib/Symbols/index.html#type-bound">AltErgoLib.Symbols.bound</a> * <a href="../AltErgoLib/Symbols/index.html#type-bound">AltErgoLib.Symbols.bound</a></code></td><td class="doc"><p>Represent floating point intervals (used for triggers in Floating point arithmetic theory). <code>TTinInterval (lower, l_strict, t, upper, u_strict)</code> is a constraint stating that term <code>t</code> is in the interval <code>lower, upper</code>, and that the lower (resp. upper) bound is strict iff <code>l_strict</code> (resp. <code>u_strict</code>) is true.</p></td></tr><tr id="type-tt_desc.TTget" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTget" class="anchor"></a><code>| </code><code><span class="constructor">TTget</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Get operation on arrays</p></td></tr><tr id="type-tt_desc.TTset" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTset" class="anchor"></a><code>| </code><code><span class="constructor">TTset</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Set operation on arrays</p></td></tr><tr id="type-tt_desc.TTextract" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTextract" class="anchor"></a><code>| </code><code><span class="constructor">TTextract</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Extract a sub-bitvector</p></td></tr><tr id="type-tt_desc.TTconcat" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTconcat" class="anchor"></a><code>| </code><code><span class="constructor">TTconcat</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td></tr><tr id="type-tt_desc.TTdot" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTdot" class="anchor"></a><code>| </code><code><span class="constructor">TTdot</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a></code></td><td class="doc"><p>Field access on structs/records</p></td></tr><tr id="type-tt_desc.TTrecord" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTrecord" class="anchor"></a><code>| </code><code><span class="constructor">TTrecord</span> <span class="keyword">of</span> <span><span>(<a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span>)</span> list</span></code></td><td class="doc"><p>Record creation.</p></td></tr><tr id="type-tt_desc.TTlet" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTlet" class="anchor"></a><code>| </code><code><span class="constructor">TTlet</span> <span class="keyword">of</span> <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span>)</span> list</span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Let-bindings. Accept a list of mutually recursive le-bindings.</p></td></tr><tr id="type-tt_desc.TTnamed" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTnamed" class="anchor"></a><code>| </code><code><span class="constructor">TTnamed</span> <span class="keyword">of</span> <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Attach a label to a term.</p></td></tr><tr id="type-tt_desc.TTite" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTite" class="anchor"></a><code>| </code><code><span class="constructor">TTite</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Conditional branching, of the form <code>TTite (condition, then_branch, else_branch)</code>.</p></td></tr><tr id="type-tt_desc.TTproject" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTproject" class="anchor"></a><code>| </code><code><span class="constructor">TTproject</span> <span class="keyword">of</span> bool * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a></code></td><td class="doc"><p>Field (conditional) access on ADTs. The boolean is true when the projection is 'guarded' and cannot be simplified (because functions are total)</p></td></tr><tr id="type-tt_desc.TTmatch" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTmatch" class="anchor"></a><code>| </code><code><span class="constructor">TTmatch</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span>(<a href="index.html#type-pattern">pattern</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span>)</span> list</span></code></td><td class="doc"><p>pattern matching on ADTs</p></td></tr><tr id="type-tt_desc.TTform" class="anchored"><td class="def constructor"><a href="#type-tt_desc.TTform" class="anchor"></a><code>| </code><code><span class="constructor">TTform</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>formulas inside terms: simple way to add them without making a lot of changes</p></td></tr></table></dt><dd><p>Typed terms descriptors.</p></dd></dl><dl><dt class="spec type" id="type-atatom"><a href="#type-atatom" class="anchor"></a><code><span class="keyword">and</span> <span>'a atatom</span></code><code> = <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-tatom">tatom</a></span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-annoted">annoted</a></span></code></dt><dd><p>Type alias for annoted typed atoms.</p></dd></dl><dl><dt class="spec type" id="type-tatom"><a href="#type-tatom" class="anchor"></a><code><span class="keyword">and</span> <span>'a tatom</span></code><code> = </code><table class="variant"><tr id="type-tatom.TAtrue" class="anchored"><td class="def constructor"><a href="#type-tatom.TAtrue" class="anchor"></a><code>| </code><code><span class="constructor">TAtrue</span></code></td><td class="doc"><p>The <code>true</code> atom</p></td></tr><tr id="type-tatom.TAfalse" class="anchored"><td class="def constructor"><a href="#type-tatom.TAfalse" class="anchor"></a><code>| </code><code><span class="constructor">TAfalse</span></code></td><td class="doc"><p>The <code>false</code> atom</p></td></tr><tr id="type-tatom.TAeq" class="anchored"><td class="def constructor"><a href="#type-tatom.TAeq" class="anchor"></a><code>| </code><code><span class="constructor">TAeq</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span></code></td><td class="doc"><p>Equality of a set of typed terms.</p></td></tr><tr id="type-tatom.TAdistinct" class="anchored"><td class="def constructor"><a href="#type-tatom.TAdistinct" class="anchor"></a><code>| </code><code><span class="constructor">TAdistinct</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span></code></td><td class="doc"><p>Disequality. All terms in the set are pairwise distinct.</p></td></tr><tr id="type-tatom.TAneq" class="anchored"><td class="def constructor"><a href="#type-tatom.TAneq" class="anchor"></a><code>| </code><code><span class="constructor">TAneq</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span></code></td><td class="doc"><p>Equality negation: at least two elements in the list are not equal.</p></td></tr><tr id="type-tatom.TAle" class="anchored"><td class="def constructor"><a href="#type-tatom.TAle" class="anchor"></a><code>| </code><code><span class="constructor">TAle</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span></code></td><td class="doc"><p>Arithmetic ordering: lesser or equal. Chained on lists of terms.</p></td></tr><tr id="type-tatom.TAlt" class="anchored"><td class="def constructor"><a href="#type-tatom.TAlt" class="anchor"></a><code>| </code><code><span class="constructor">TAlt</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span></code></td><td class="doc"><p>Strict arithmetic ordering: less than. Chained on lists of terms.</p></td></tr><tr id="type-tatom.TApred" class="anchored"><td class="def constructor"><a href="#type-tatom.TApred" class="anchor"></a><code>| </code><code><span class="constructor">TApred</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * bool</code></td><td class="doc"><p>Term predicate, negated if the boolean is true. <code>TApred (t, negated)</code> is satisfied iff <code>t &lt;=&gt; not negated</code></p></td></tr><tr id="type-tatom.TTisConstr" class="anchored"><td class="def constructor"><a href="#type-tatom.TTisConstr" class="anchor"></a><code>| </code><code><span class="constructor">TTisConstr</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a></code></td><td class="doc"><p>Test if the given term's head symbol is identitical to the provided ADT consturctor</p></td></tr></table></dt></dl><aside><p>Typed atoms.</p></aside><dl><dt class="spec type" id="type-quant_form"><a href="#type-quant_form" class="anchor"></a><code><span class="keyword">and</span> <span>'a quant_form</span></code><code> = </code><code>{</code><table class="record"><tr id="type-quant_form.qf_bvars" class="anchored"><td class="def field"><a href="#type-quant_form.qf_bvars" class="anchor"></a><code>qf_bvars : <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span>;</code></td><td class="doc"><p>Variables that are quantified by this formula.</p></td></tr><tr id="type-quant_form.qf_upvars" class="anchored"><td class="def field"><a href="#type-quant_form.qf_upvars" class="anchor"></a><code>qf_upvars : <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span>;</code></td><td class="doc"><p>Free variables that occur in the formula.</p></td></tr><tr id="type-quant_form.qf_triggers" class="anchored"><td class="def field"><a href="#type-quant_form.qf_triggers" class="anchor"></a><code>qf_triggers : <span><span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span> * bool)</span> list</span>;</code></td><td class="doc"><p>Triggers associated wiht the formula. For each trigger, the boolean specifies whether the trigger was given in the input file (compared to inferred).</p></td></tr><tr id="type-quant_form.qf_hyp" class="anchored"><td class="def field"><a href="#type-quant_form.qf_hyp" class="anchor"></a><code>qf_hyp : <span><span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span> list</span>;</code></td><td class="doc"><p>Hypotheses of axioms with semantic triggers in FPA theory. Typically, these hypotheses reduce to TRUE after instantiation</p></td></tr><tr id="type-quant_form.qf_form" class="anchored"><td class="def field"><a href="#type-quant_form.qf_form" class="anchor"></a><code>qf_form : <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span>;</code></td><td class="doc"><p>The quantified formula.</p></td></tr></table><code>}</code></dt><dd><p>Quantified formulas.</p></dd></dl><dl><dt class="spec type" id="type-atform"><a href="#type-atform" class="anchor"></a><code><span class="keyword">and</span> <span>'a atform</span></code><code> = <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-tform">tform</a></span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-annoted">annoted</a></span></code></dt><dd><p>Type alias for typed annoted formulas.</p></dd></dl><dl><dt class="spec type" id="type-tform"><a href="#type-tform" class="anchor"></a><code><span class="keyword">and</span> <span>'a tform</span></code><code> = </code><table class="variant"><tr id="type-tform.TFatom" class="anchored"><td class="def constructor"><a href="#type-tform.TFatom" class="anchor"></a><code>| </code><code><span class="constructor">TFatom</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atatom">atatom</a></span></code></td><td class="doc"><p>Atomic formula.</p></td></tr><tr id="type-tform.TFop" class="anchored"><td class="def constructor"><a href="#type-tform.TFop" class="anchor"></a><code>| </code><code><span class="constructor">TFop</span> <span class="keyword">of</span> <a href="index.html#type-oplogic">oplogic</a> * <span><span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span> list</span></code></td><td class="doc"><p>Application of logical operators.</p></td></tr><tr id="type-tform.TFforall" class="anchored"><td class="def constructor"><a href="#type-tform.TFforall" class="anchor"></a><code>| </code><code><span class="constructor">TFforall</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-quant_form">quant_form</a></span></code></td><td class="doc"><p>Universal quantification.</p></td></tr><tr id="type-tform.TFexists" class="anchored"><td class="def constructor"><a href="#type-tform.TFexists" class="anchor"></a><code>| </code><code><span class="constructor">TFexists</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-quant_form">quant_form</a></span></code></td><td class="doc"><p>Existencial quantification.</p></td></tr><tr id="type-tform.TFlet" class="anchored"><td class="def constructor"><a href="#type-tform.TFlet" class="anchor"></a><code>| </code><code><span class="constructor">TFlet</span> <span class="keyword">of</span> <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span> * <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-tlet_kind">tlet_kind</a></span>)</span> list</span> * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>Let binding. TODO: what is in the first list ?</p></td></tr><tr id="type-tform.TFnamed" class="anchored"><td class="def constructor"><a href="#type-tform.TFnamed" class="anchor"></a><code>| </code><code><span class="constructor">TFnamed</span> <span class="keyword">of</span> <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>Attach a name to a formula.</p></td></tr><tr id="type-tform.TFmatch" class="anchored"><td class="def constructor"><a href="#type-tform.TFmatch" class="anchor"></a><code>| </code><code><span class="constructor">TFmatch</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> * <span><span>(<a href="index.html#type-pattern">pattern</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span>)</span> list</span></code></td><td class="doc"><p>pattern matching on ADTs</p></td></tr></table></dt></dl><aside><p>Typed formulas.</p></aside><dl><dt class="spec type" id="type-tlet_kind"><a href="#type-tlet_kind" class="anchor"></a><code><span class="keyword">and</span> <span>'a tlet_kind</span></code><code> = </code><table class="variant"><tr id="type-tlet_kind.TletTerm" class="anchored"><td class="def constructor"><a href="#type-tlet_kind.TletTerm" class="anchor"></a><code>| </code><code><span class="constructor">TletTerm</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span></code></td><td class="doc"><p>Term let-binding</p></td></tr><tr id="type-tlet_kind.TletForm" class="anchored"><td class="def constructor"><a href="#type-tlet_kind.TletForm" class="anchor"></a><code>| </code><code><span class="constructor">TletForm</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>Formula let-binding</p></td></tr></table></dt><dd><p>The different kinds of let-bindings, whether they bind terms or formulas.</p></dd></dl></section><section><header><h3 id="declarations"><a href="#declarations" class="anchor"></a>Declarations</h3></header><dl><dt class="spec type" id="type-rwt_rule"><a href="#type-rwt_rule" class="anchor"></a><code><span class="keyword">type</span> <span>'a rwt_rule</span></code><code> = </code><code>{</code><table class="record"><tr id="type-rwt_rule.rwt_vars" class="anchored"><td class="def field"><a href="#type-rwt_rule.rwt_vars" class="anchor"></a><code>rwt_vars : <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span>;</code></td><td class="doc"><p>Variables of the rewrite rule</p></td></tr><tr id="type-rwt_rule.rwt_left" class="anchored"><td class="def field"><a href="#type-rwt_rule.rwt_left" class="anchor"></a><code>rwt_left : <span class="type-var">'a</span>;</code></td><td class="doc"><p>Left side of the rewrite rule (aka pattern).</p></td></tr><tr id="type-rwt_rule.rwt_right" class="anchored"><td class="def field"><a href="#type-rwt_rule.rwt_right" class="anchor"></a><code>rwt_right : <span class="type-var">'a</span>;</code></td><td class="doc"><p>Right side of the rewrite rule.</p></td></tr></table><code>}</code></dt><dd><p>Rewrite rules. Polymorphic to allow for different representation of terms.</p></dd></dl><dl><dt class="spec type" id="type-goal_sort"><a href="#type-goal_sort" class="anchor"></a><code><span class="keyword">type</span> goal_sort</code><code> = </code><table class="variant"><tr id="type-goal_sort.Cut" class="anchored"><td class="def constructor"><a href="#type-goal_sort.Cut" class="anchor"></a><code>| </code><code><span class="constructor">Cut</span></code></td><td class="doc"><p>Introduce a cut in a goal. Once the cut proved, it's added as a hypothesis.</p></td></tr><tr id="type-goal_sort.Check" class="anchored"><td class="def constructor"><a href="#type-goal_sort.Check" class="anchor"></a><code>| </code><code><span class="constructor">Check</span></code></td><td class="doc"><p>Check if some intermediate assertion is prouvable</p></td></tr><tr id="type-goal_sort.Thm" class="anchored"><td class="def constructor"><a href="#type-goal_sort.Thm" class="anchor"></a><code>| </code><code><span class="constructor">Thm</span></code></td><td class="doc"><p>The goal to be proved</p></td></tr></table></dt><dd><p>Goal sort. Used in typed declarations.</p></dd></dl><dl><dt class="spec value" id="val-fresh_hypothesis_name"><a href="#val-fresh_hypothesis_name" class="anchor"></a><code><span class="keyword">val</span> fresh_hypothesis_name : <a href="index.html#type-goal_sort">goal_sort</a> <span>&#45;&gt;</span> string</code></dt><dd><p>create a fresh hypothesis name given a goal sort.</p></dd></dl><dl><dt class="spec value" id="val-is_local_hyp"><a href="#val-is_local_hyp" class="anchor"></a><code><span class="keyword">val</span> is_local_hyp : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Assuming a name generated by <a href="index.html#val-fresh_hypothesis_name"><code>fresh_hypothesis_name</code></a>, answers whether the name design a local hypothesis ?</p></dd></dl><dl><dt class="spec value" id="val-is_global_hyp"><a href="#val-is_global_hyp" class="anchor"></a><code><span class="keyword">val</span> is_global_hyp : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Assuming a name generated by <a href="index.html#val-fresh_hypothesis_name"><code>fresh_hypothesis_name</code></a>, does the name design a global hypothesis ?</p></dd></dl><dl><dt class="spec type" id="type-tlogic_type"><a href="#type-tlogic_type" class="anchor"></a><code><span class="keyword">type</span> tlogic_type</code><code> = </code><table class="variant"><tr id="type-tlogic_type.TPredicate" class="anchored"><td class="def constructor"><a href="#type-tlogic_type.TPredicate" class="anchor"></a><code>| </code><code><span class="constructor">TPredicate</span> <span class="keyword">of</span> <span><a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a> list</span></code></td><td class="doc"><p>Predicate type declarations</p></td></tr><tr id="type-tlogic_type.TFunction" class="anchored"><td class="def constructor"><a href="#type-tlogic_type.TFunction" class="anchor"></a><code>| </code><code><span class="constructor">TFunction</span> <span class="keyword">of</span> <span><a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a> list</span> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a></code></td><td class="doc"><p>Function type declarations</p></td></tr></table></dt><dd><p>Type declarations. Specifies the list of argument types, as well as the return type for functions (predicate implicitly returns a proposition, so there is no need for an explicit return type).</p></dd></dl><dl><dt class="spec type" id="type-atdecl"><a href="#type-atdecl" class="anchor"></a><code><span class="keyword">type</span> <span>'a atdecl</span></code><code> = <span><span>(<span><span class="type-var">'a</span> <a href="index.html#type-tdecl">tdecl</a></span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-annoted">annoted</a></span></code></dt><dd><p>Type alias for annoted typed declarations.</p></dd></dl><dl><dt class="spec type" id="type-tdecl"><a href="#type-tdecl" class="anchor"></a><code><span class="keyword">and</span> <span>'a tdecl</span></code><code> = </code><table class="variant"><tr id="type-tdecl.TTheory" class="anchored"><td class="def constructor"><a href="#type-tdecl.TTheory" class="anchor"></a><code>| </code><code><span class="constructor">TTheory</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * string * <a href="../AltErgoLib/Util/index.html#type-theories_extensions">AltErgoLib.Util.theories_extensions</a> * <span><span><span class="type-var">'a</span> <a href="index.html#type-atdecl">atdecl</a></span> list</span></code></td><td class="doc"><p>Theory declarations. The list of declarations in a Theory may only contain Axioms.</p></td></tr><tr id="type-tdecl.TAxiom" class="anchored"><td class="def constructor"><a href="#type-tdecl.TAxiom" class="anchor"></a><code>| </code><code><span class="constructor">TAxiom</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * string * <a href="../AltErgoLib/Util/index.html#type-axiom_kind">AltErgoLib.Util.axiom_kind</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>New axiom that can be used in proofs.</p></td></tr><tr id="type-tdecl.TRewriting" class="anchored"><td class="def constructor"><a href="#type-tdecl.TRewriting" class="anchor"></a><code>| </code><code><span class="constructor">TRewriting</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * string * <span><span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> <a href="index.html#type-rwt_rule">rwt_rule</a></span> list</span></code></td><td class="doc"><p>New rewrite rule that can be used.</p></td></tr><tr id="type-tdecl.TGoal" class="anchored"><td class="def constructor"><a href="#type-tdecl.TGoal" class="anchor"></a><code>| </code><code><span class="constructor">TGoal</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * <a href="index.html#type-goal_sort">goal_sort</a> * string * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>New goal to prove.</p></td></tr><tr id="type-tdecl.TLogic" class="anchored"><td class="def constructor"><a href="#type-tdecl.TLogic" class="anchor"></a><code>| </code><code><span class="constructor">TLogic</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * <span>string list</span> * <a href="index.html#type-tlogic_type">tlogic_type</a></code></td><td class="doc"><p>Function (or predicate) type declaration.</p></td></tr><tr id="type-tdecl.TPredicate_def" class="anchored"><td class="def constructor"><a href="#type-tdecl.TPredicate_def" class="anchor"></a><code>| </code><code><span class="constructor">TPredicate_def</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * string * <span><span>(string * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span> * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>Predicate definition. <code>TPredicate_def (loc, name, vars, body)</code> defines a predicate <code>fun vars =&gt; body</code>.</p></td></tr><tr id="type-tdecl.TFunction_def" class="anchored"><td class="def constructor"><a href="#type-tdecl.TFunction_def" class="anchor"></a><code>| </code><code><span class="constructor">TFunction_def</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * string * <span><span>(string * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a> * <span><span class="type-var">'a</span> <a href="index.html#type-atform">atform</a></span></code></td><td class="doc"><p>Predicate definition. <code>TPredicate_def (loc, name, vars, ret, body)</code> defines a function <code>fun vars =&gt; body</code>, where body has type <code>ret</code>.</p></td></tr><tr id="type-tdecl.TTypeDecl" class="anchored"><td class="def constructor"><a href="#type-tdecl.TTypeDecl" class="anchor"></a><code>| </code><code><span class="constructor">TTypeDecl</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a></code></td><td class="doc"><p>New type declaration. <code>TTypeDecl (loc, vars, t, body)</code> declares a type <code>t</code>, with parameters <code>vars</code>, and with contents <code>body</code>. This new type may either be abstract, a record type, or an enumeration.</p></td></tr><tr id="type-tdecl.TPush" class="anchored"><td class="def constructor"><a href="#type-tdecl.TPush" class="anchor"></a><code>| </code><code><span class="constructor">TPush</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * int</code></td><td class="doc"><p><code>push (loc,n)</code> pushs n new assertions levels onto the assertion stack</p></td></tr><tr id="type-tdecl.TPop" class="anchored"><td class="def constructor"><a href="#type-tdecl.TPop" class="anchor"></a><code>| </code><code><span class="constructor">TPop</span> <span class="keyword">of</span> <a href="../AltErgoLib/Loc/index.html#type-t">AltErgoLib.Loc.t</a> * int</code></td><td class="doc"><p><code>pop (loc,n)</code> pops n assertions levels from the assertion stack</p></td></tr></table></dt></dl><aside><p>Typed declarations.</p></aside><section><header><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6></header><dl><dt class="spec value" id="val-print_term"><a href="#val-print_term" class="anchor"></a><code><span class="keyword">val</span> print_term : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-atterm">atterm</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print annoted typed terms. Ignore the annotations.</p></dd></dl><dl><dt class="spec value" id="val-print_formula"><a href="#val-print_formula" class="anchor"></a><code><span class="keyword">val</span> print_formula : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-atform">atform</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print annoted typed formulas; Ignores the annotations.</p></dd></dl><dl><dt class="spec value" id="val-print_binders"><a href="#val-print_binders" class="anchor"></a><code><span class="keyword">val</span> print_binders : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<a href="../AltErgoLib/Symbols/index.html#type-t">AltErgoLib.Symbols.t</a> * <a href="../AltErgoLib/Ty/index.html#type-t">AltErgoLib.Ty.t</a>)</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print a list of bound typed variables.</p></dd></dl><dl><dt class="spec value" id="val-print_triggers"><a href="#val-print_triggers" class="anchor"></a><code><span class="keyword">val</span> print_triggers : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span>(<span><span><span class="type-var">'a</span> <a href="index.html#type-atterm">atterm</a></span> list</span> * bool)</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print a list of triggers.</p></dd></dl><dl><dt class="spec value" id="val-print_goal_sort"><a href="#val-print_goal_sort" class="anchor"></a><code><span class="keyword">val</span> print_goal_sort : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-goal_sort">goal_sort</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print a goal sort</p></dd></dl><dl><dt class="spec value" id="val-print_rwt"><a href="#val-print_rwt" class="anchor"></a><code><span class="keyword">val</span> print_rwt : <span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-rwt_rule">rwt_rule</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print a rewrite rule</p></dd></dl></section></section></div></body></html>