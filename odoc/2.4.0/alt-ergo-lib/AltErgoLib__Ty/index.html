<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>AltErgoLib__Ty (alt-ergo-lib.AltErgoLib__Ty)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">alt-ergo-lib</a> &#x00BB; AltErgoLib__Ty</nav><h1>Module <code>AltErgoLib__Ty</code></h1><p>Types</p><p>This module defines the representation of types.</p><nav class="toc"><ul><li><a href="#definition">Definition</a></li><li><a href="#type-inspection">Type inspection</a></li><li><a href="#building-types">Building types</a></li><li><a href="#substitutions">Substitutions</a></li><li><a href="#unification/matching">Unification/Matching</a></li><li><a href="#manipulations-on-types">Manipulations on types</a></li></ul></nav></header><section><header><h3 id="definition"><a href="#definition" class="anchor"></a>Definition</h3></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><table class="variant"><tr id="type-t.Tint" class="anchored"><td class="def constructor"><a href="#type-t.Tint" class="anchor"></a><code>| </code><code><span class="constructor">Tint</span></code></td><td class="doc"><p>Integer numbers</p></td></tr><tr id="type-t.Treal" class="anchored"><td class="def constructor"><a href="#type-t.Treal" class="anchor"></a><code>| </code><code><span class="constructor">Treal</span></code></td><td class="doc"><p>Real numbers</p></td></tr><tr id="type-t.Tbool" class="anchored"><td class="def constructor"><a href="#type-t.Tbool" class="anchor"></a><code>| </code><code><span class="constructor">Tbool</span></code></td><td class="doc"><p>Booleans</p></td></tr><tr id="type-t.Tunit" class="anchored"><td class="def constructor"><a href="#type-t.Tunit" class="anchor"></a><code>| </code><code><span class="constructor">Tunit</span></code></td><td class="doc"><p>The unit type</p></td></tr><tr id="type-t.Tvar" class="anchored"><td class="def constructor"><a href="#type-t.Tvar" class="anchor"></a><code>| </code><code><span class="constructor">Tvar</span> <span class="keyword">of</span> <a href="index.html#type-tvar">tvar</a></code></td><td class="doc"><p>Type variables</p></td></tr><tr id="type-t.Tbitv" class="anchored"><td class="def constructor"><a href="#type-t.Tbitv" class="anchor"></a><code>| </code><code><span class="constructor">Tbitv</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Bitvectors of a given length</p></td></tr><tr id="type-t.Text" class="anchored"><td class="def constructor"><a href="#type-t.Text" class="anchor"></a><code>| </code><code><span class="constructor">Text</span> <span class="keyword">of</span> <span><a href="index.html#type-t">t</a> list</span> * <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a></code></td><td class="doc"><p>Abstract types applied to arguments. <code>Text (args, s)</code> is the application of the abstract type constructor <code>s</code> to arguments <code>args</code>.</p></td></tr><tr id="type-t.Tfarray" class="anchored"><td class="def constructor"><a href="#type-t.Tfarray" class="anchor"></a><code>| </code><code><span class="constructor">Tfarray</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></td><td class="doc"><p>Functional arrays. <code>TFarray (src,dst)</code> maps values of type <code>src</code> to values of type <code>dst</code>.</p></td></tr><tr id="type-t.Tsum" class="anchored"><td class="def constructor"><a href="#type-t.Tsum" class="anchor"></a><code>| </code><code><span class="constructor">Tsum</span> <span class="keyword">of</span> <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <span><a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> list</span></code></td><td class="doc"><p>Enumeration, with its name, and the list of its constructors.</p></td></tr><tr id="type-t.Tadt" class="anchored"><td class="def constructor"><a href="#type-t.Tadt" class="anchor"></a><code>| </code><code><span class="constructor">Tadt</span> <span class="keyword">of</span> <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <span><a href="index.html#type-t">t</a> list</span></code></td><td class="doc"><p>Algebraic types applied to arguments. <code>Tadt (s, args)</code> is the application of the datatype constructor <code>s</code> to arguments <code>args</code>.</p></td></tr><tr id="type-t.Trecord" class="anchored"><td class="def constructor"><a href="#type-t.Trecord" class="anchor"></a><code>| </code><code><span class="constructor">Trecord</span> <span class="keyword">of</span> <a href="index.html#type-trecord">trecord</a></code></td><td class="doc"><p>Record type.</p></td></tr></table></dt><dt class="spec type" id="type-tvar"><a href="#type-tvar" class="anchor"></a><code><span class="keyword">and</span> tvar</code><code> = </code><code>{</code><table class="record"><tr id="type-tvar.v" class="anchored"><td class="def field"><a href="#type-tvar.v" class="anchor"></a><code>v : int;</code></td><td class="doc"><p>Unique identifier</p></td></tr><tr id="type-tvar.value" class="anchored"><td class="def field"><a href="#type-tvar.value" class="anchor"></a><code><span class="keyword">mutable</span> value : <span><a href="index.html#type-t">t</a> option</span>;</code></td><td class="doc"><p>Pointer to the current value of the type variable.</p></td></tr></table><code>}</code></dt><dd><p>Type variables. The <code>value</code> field is mutated during unification, hence distinct types should have disjoints sets of type variables (see function <a href="index.html#val-fresh"><code>fresh</code></a>).</p></dd></dl><dl><dt class="spec type" id="type-trecord"><a href="#type-trecord" class="anchor"></a><code><span class="keyword">and</span> trecord</code><code> = </code><code>{</code><table class="record"><tr id="type-trecord.args" class="anchored"><td class="def field"><a href="#type-trecord.args" class="anchor"></a><code><span class="keyword">mutable</span> args : <span><a href="index.html#type-t">t</a> list</span>;</code></td><td class="doc"><p>Arguments passed to the record constructor</p></td></tr><tr id="type-trecord.name" class="anchored"><td class="def field"><a href="#type-trecord.name" class="anchor"></a><code>name : <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a>;</code></td><td class="doc"><p>Name of the record type</p></td></tr><tr id="type-trecord.lbs" class="anchored"><td class="def field"><a href="#type-trecord.lbs" class="anchor"></a><code><span class="keyword">mutable</span> lbs : <span><span>(<a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <a href="index.html#type-t">t</a>)</span> list</span>;</code></td><td class="doc"><p>List of fields of the record. Each field has a name, and an associated type.</p></td></tr><tr id="type-trecord.record_constr" class="anchored"><td class="def field"><a href="#type-trecord.record_constr" class="anchor"></a><code>record_constr : <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a>;</code></td><td class="doc"><p>record constructor. Useful is case it's a specialization of an algeberaic datatype. Default value is &quot;{__<code>name</code>&quot;</p></td></tr></table><code>}</code></dt><dd><p>Record types.</p></dd></dl><dl><dt class="spec type" id="type-adt_constr"><a href="#type-adt_constr" class="anchor"></a><code><span class="keyword">type</span> adt_constr</code><code> = </code><code>{</code><table class="record"><tr id="type-adt_constr.constr" class="anchored"><td class="def field"><a href="#type-adt_constr.constr" class="anchor"></a><code>constr : <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a>;</code></td><td class="doc"><p>constructor of an ADT type</p></td></tr><tr id="type-adt_constr.destrs" class="anchored"><td class="def field"><a href="#type-adt_constr.destrs" class="anchor"></a><code>destrs : <span><span>(<a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <a href="index.html#type-t">t</a>)</span> list</span>;</code></td><td class="doc"><p>the list of destructors associated with the constructor and their respective types</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-type_body"><a href="#type-type_body" class="anchor"></a><code><span class="keyword">type</span> type_body</code><code> = </code><table class="variant"><tr id="type-type_body.Adt" class="anchored"><td class="def constructor"><a href="#type-type_body.Adt" class="anchor"></a><code>| </code><code><span class="constructor">Adt</span> <span class="keyword">of</span> <span><a href="index.html#type-adt_constr">adt_constr</a> list</span></code></td><td class="doc"><p>body of an algebraic datatype</p></td></tr></table></dt><dd><p>bodies of types definitions. Currently, bodies are inlined in the type <code>t</code> for records and enumerations. But, this is not possible for recursive ADTs</p></dd></dl><dl><dt class="spec module" id="module-Svty"><a href="#module-Svty" class="anchor"></a><code><span class="keyword">module</span> Svty : Stdlib.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Svty">Svty</a>.elt = int</code></dt><dd><p>Sets of type variables, indexed by their identifier.</p></dd></dl><dl><dt class="spec module" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span class="keyword">module</span> Set : Stdlib.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-Set">Set</a>.elt = <a href="index.html#type-t">t</a></code></dt><dd><p>Sets of types</p></dd></dl><dl><dt class="spec value" id="val-assoc_destrs"><a href="#val-assoc_destrs" class="anchor"></a><code><span class="keyword">val</span> assoc_destrs : <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-adt_constr">adt_constr</a> list</span> <span>&#45;&gt;</span> <span><span>(<a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> * <a href="index.html#type-t">t</a>)</span> list</span></code></dt><dd><p>returns the list of destructors associated with the given consturctor. raises Not_found if the constructor is not in the given list</p></dd></dl><dl><dt class="spec value" id="val-type_body"><a href="#val-type_body" class="anchor"></a><code><span class="keyword">val</span> type_body : <a href="../AltErgoLib/Hstring/index.html#type-t">AltErgoLib.Hstring.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-type_body">type_body</a></code></dt></dl></section><section><header><h3 id="type-inspection"><a href="#type-inspection" class="anchor"></a>Type inspection</h3></header><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val</span> hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Hash function</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Equality function</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Comparison function</p></dd></dl><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Printing function for types (does not print the type of each fields for records).</p></dd></dl><dl><dt class="spec value" id="val-print_list"><a href="#val-print_list" class="anchor"></a><code><span class="keyword">val</span> print_list : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print function for lists of types (does not print the type of each fields for records).</p></dd></dl><dl><dt class="spec value" id="val-print_full"><a href="#val-print_full" class="anchor"></a><code><span class="keyword">val</span> print_full : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print function including the record fields.</p></dd></dl><dl><dt class="spec value" id="val-vty_of"><a href="#val-vty_of" class="anchor"></a><code><span class="keyword">val</span> vty_of : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#module-Svty">Svty</a>.t</code></dt><dd><p>Returns the set of type variables that occur in a given type.</p></dd></dl></section><section><header><h3 id="building-types"><a href="#building-types" class="anchor"></a>Building types</h3></header><dl><dt class="spec value" id="val-tunit"><a href="#val-tunit" class="anchor"></a><code><span class="keyword">val</span> tunit : <a href="index.html#type-t">t</a></code></dt><dd><p>The unit type.</p></dd></dl><dl><dt class="spec value" id="val-fresh_var"><a href="#val-fresh_var" class="anchor"></a><code><span class="keyword">val</span> fresh_var : unit <span>&#45;&gt;</span> <a href="index.html#type-tvar">tvar</a></code></dt><dd><p>Generate a fresh type variable, guaranteed to be distinct from any other previously generated by this function.</p></dd></dl><dl><dt class="spec value" id="val-fresh_tvar"><a href="#val-fresh_tvar" class="anchor"></a><code><span class="keyword">val</span> fresh_tvar : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Wrap the <a href="index.html#val-fresh_var"><code>fresh_var</code></a> function to return a type.</p></dd></dl><dl><dt class="spec value" id="val-fresh_empty_text"><a href="#val-fresh_empty_text" class="anchor"></a><code><span class="keyword">val</span> fresh_empty_text : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return a fesh abstract type.</p></dd></dl><dl><dt class="spec value" id="val-text"><a href="#val-text" class="anchor"></a><code><span class="keyword">val</span> text : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply the abstract type constructor to the list of type arguments given.</p></dd></dl><dl><dt class="spec value" id="val-tsum"><a href="#val-tsum" class="anchor"></a><code><span class="keyword">val</span> tsum : string <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create an enumeration type. <code>tsum name enums</code> creates an enumeration named <code>name</code>, with constructors <code>enums</code>.</p></dd></dl><dl><dt class="spec value" id="val-t_adt"><a href="#val-t_adt" class="anchor"></a><code><span class="keyword">val</span> t_adt : <span>?&#8288;body:<span><span><span>(string * <span><span>(string * <a href="index.html#type-t">t</a>)</span> list</span>)</span> list</span> option</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Crearte and algebraic datatype. The body is a list of constructors, where each constructor is associated with the list of its destructors with their respective types. If <code>body</code> is none, then no definition will be registered for this type. The second argument is the name of the type. The third one provides its list of arguments.</p></dd></dl><dl><dt class="spec value" id="val-trecord"><a href="#val-trecord" class="anchor"></a><code><span class="keyword">val</span> trecord : <span>?&#8288;record_constr:string</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(string * <a href="index.html#type-t">t</a>)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Create a record type. <code>trecord args name lbs</code> creates a record type with name <code>name</code>, arguments <code>args</code> and fields <code>lbs</code>.</p></dd></dl></section><section><header><h3 id="substitutions"><a href="#substitutions" class="anchor"></a>Substitutions</h3></header><dl><dt class="spec module" id="module-M"><a href="#module-M" class="anchor"></a><code><span class="keyword">module</span> M : Stdlib.Map.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-M">M</a>.key = int</code></dt><dd><p>Maps from type variables identifiers.</p></dd></dl><dl><dt class="spec type" id="type-subst"><a href="#type-subst" class="anchor"></a><code><span class="keyword">type</span> subst</code><code> = <span><a href="index.html#type-t">t</a> <a href="index.html#module-M">M</a>.t</span></code></dt><dd><p>The type of substitution, i.e. maps from type variables identifiers to types.</p></dd></dl><dl><dt class="spec value" id="val-compare_subst"><a href="#val-compare_subst" class="anchor"></a><code><span class="keyword">val</span> compare_subst : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Comparison of substitutions.</p></dd></dl><dl><dt class="spec value" id="val-equal_subst"><a href="#val-equal_subst" class="anchor"></a><code><span class="keyword">val</span> equal_subst : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Equality of substitutions.</p></dd></dl><dl><dt class="spec value" id="val-print_subst"><a href="#val-print_subst" class="anchor"></a><code><span class="keyword">val</span> print_subst : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Print function for substitutions.</p></dd></dl><dl><dt class="spec value" id="val-esubst"><a href="#val-esubst" class="anchor"></a><code><span class="keyword">val</span> esubst : <a href="index.html#type-subst">subst</a></code></dt><dd><p>The empty substitution, a.k.a. the identity.</p></dd></dl><dl><dt class="spec value" id="val-apply_subst"><a href="#val-apply_subst" class="anchor"></a><code><span class="keyword">val</span> apply_subst : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Substitution application.</p></dd></dl><dl><dt class="spec value" id="val-union_subst"><a href="#val-union_subst" class="anchor"></a><code><span class="keyword">val</span> union_subst : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a></code></dt><dd><p><code>union_subst u v</code> applies <code>v</code> to <code>u</code>, resulting in <code>u'</code>. It then computes the union of <code>u'</code> and <code>v</code>, prioritizing bindings from <code>u'</code> in case of conflict.</p></dd></dl></section><section><header><h3 id="unification/matching"><a href="#unification/matching" class="anchor"></a>Unification/Matching</h3></header><dl><dt class="spec exception" id="exception-TypeClash"><a href="#exception-TypeClash" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">TypeClash</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-t">t</a></code></dt><dd><p>Exception raised during matching or unification. <code>TypeClash (u, v)</code> is raised when <code>u</code> and <code>v</code> could not be matched or unified (<code>u</code> and <code>v</code> may be sub-types of the types being actually unified or matched).</p></dd></dl><dl><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val</span> unify : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Destructive unification. Mutates the <code>value</code> fields of type variables.</p><dl><dt>raises TypeClash</dt><dd><p>when unification is impossible. In this case, the <code>value</code> fields of already mutated type variables are left modified, which may prevent future unifications.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-matching"><a href="#val-matching" class="anchor"></a><code><span class="keyword">val</span> matching : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a></code></dt><dd><p>Matching of types (non-destructive). <code>matching pat t</code> returns a substitution <code>subst</code> such that <code>apply_subst subst pat</code> is equal to <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-shorten"><a href="#val-shorten" class="anchor"></a><code><span class="keyword">val</span> shorten : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Shorten paths in type variables values. Unification in particular can create chains where the <code>value</code> field of one type variable points to another and so on... This function short-circuits such chains so that the value of a type variable can be accessed directly.</p></dd></dl></section><section><header><h3 id="manipulations-on-types"><a href="#manipulations-on-types" class="anchor"></a>Manipulations on types</h3></header><dl><dt class="spec value" id="val-fresh"><a href="#val-fresh" class="anchor"></a><code><span class="keyword">val</span> fresh : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-subst">subst</a></code></dt><dd><p>Apply the given substitution, all while generating fresh variables for the variables not already bound in the substitution. Returns a substitution containing bindings from old variable to their fresh counterpart.</p></dd></dl><dl><dt class="spec value" id="val-fresh_list"><a href="#val-fresh_list" class="anchor"></a><code><span class="keyword">val</span> fresh_list : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> * <a href="index.html#type-subst">subst</a></code></dt><dd><p>Same as <a href="index.html#val-fresh"><code>fresh</code></a> but on lists of types.</p></dd></dl><dl><dt class="spec value" id="val-instantiate"><a href="#val-instantiate" class="anchor"></a><code><span class="keyword">val</span> instantiate : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>instantiate vars args t</code> builds the substitutions mapping each type variable in <code>vars</code> to the corresponding term in <code>args</code>, then apply that substitution to <code>t</code>.</p><dl><dt>raises Invalid_argument</dt><dd><p>if the lists <code>vars</code> and <code>args</code> do not have the same length</p></dd></dl><dl><dt>raises Assertion_failure</dt><dd><p>if one type in <code>vars</code> is not a type variable.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-monomorphize"><a href="#val-monomorphize" class="anchor"></a><code><span class="keyword">val</span> monomorphize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return a monomorphized variant of the given type, where type variable without values have been replaced by abstract types.</p></dd></dl></section></div></body></html>