<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Util (alt-ergo-lib.AltErgoLib.Util)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../index.html">AltErgoLib</a> &#x00BB; Util</nav><h1>Module <code>AltErgoLib.Util</code></h1></header><dl><dt class="spec exception" id="exception-Timeout"><a href="#exception-Timeout" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Timeout</span></code></dt><dt class="spec exception" id="exception-Unsolvable"><a href="#exception-Unsolvable" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Unsolvable</span></code></dt><dt class="spec exception" id="exception-Cmp"><a href="#exception-Cmp" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Cmp</span> <span class="keyword">of</span> int</code></dt></dl><div class="spec module" id="module-MI"><a href="#module-MI" class="anchor"></a><code><span class="keyword">module</span> MI : Stdlib.Map.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-MI">MI</a>.key = int</code></div><div class="spec module" id="module-SI"><a href="#module-SI" class="anchor"></a><code><span class="keyword">module</span> SI : Stdlib.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-SI">SI</a>.elt = int</code></div><div class="spec module" id="module-SS"><a href="#module-SS" class="anchor"></a><code><span class="keyword">module</span> SS : Stdlib.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-SS">SS</a>.elt = string</code></div><dl><dt class="spec type" id="type-case_split_policy"><a href="#type-case_split_policy" class="anchor"></a><code><span class="keyword">type</span> case_split_policy</code><code> = </code><table class="variant"><tr id="type-case_split_policy.AfterTheoryAssume" class="anchored"><td class="def constructor"><a href="#type-case_split_policy.AfterTheoryAssume" class="anchor"></a><code>| </code><code><span class="constructor">AfterTheoryAssume</span></code></td></tr><tr id="type-case_split_policy.BeforeMatching" class="anchored"><td class="def constructor"><a href="#type-case_split_policy.BeforeMatching" class="anchor"></a><code>| </code><code><span class="constructor">BeforeMatching</span></code></td></tr><tr id="type-case_split_policy.AfterMatching" class="anchored"><td class="def constructor"><a href="#type-case_split_policy.AfterMatching" class="anchor"></a><code>| </code><code><span class="constructor">AfterMatching</span></code></td></tr></table></dt><dd><p>Different values for -case-split-policy option: -after-theory-assume (default value): after assuming facts in theory by the SAT -before-matching: just before performing a matching round -after-matching: just after performing a matching round *</p></dd></dl><dl><dt class="spec type" id="type-inst_kind"><a href="#type-inst_kind" class="anchor"></a><code><span class="keyword">type</span> inst_kind</code><code> = </code><table class="variant"><tr id="type-inst_kind.Normal" class="anchored"><td class="def constructor"><a href="#type-inst_kind.Normal" class="anchor"></a><code>| </code><code><span class="constructor">Normal</span></code></td></tr><tr id="type-inst_kind.Forward" class="anchored"><td class="def constructor"><a href="#type-inst_kind.Forward" class="anchor"></a><code>| </code><code><span class="constructor">Forward</span></code></td></tr><tr id="type-inst_kind.Backward" class="anchored"><td class="def constructor"><a href="#type-inst_kind.Backward" class="anchor"></a><code>| </code><code><span class="constructor">Backward</span></code></td></tr></table></dt><dt class="spec type" id="type-sat_solver"><a href="#type-sat_solver" class="anchor"></a><code><span class="keyword">type</span> sat_solver</code><code> = </code><table class="variant"><tr id="type-sat_solver.Tableaux" class="anchored"><td class="def constructor"><a href="#type-sat_solver.Tableaux" class="anchor"></a><code>| </code><code><span class="constructor">Tableaux</span></code></td></tr><tr id="type-sat_solver.Tableaux_CDCL" class="anchored"><td class="def constructor"><a href="#type-sat_solver.Tableaux_CDCL" class="anchor"></a><code>| </code><code><span class="constructor">Tableaux_CDCL</span></code></td></tr><tr id="type-sat_solver.CDCL" class="anchored"><td class="def constructor"><a href="#type-sat_solver.CDCL" class="anchor"></a><code>| </code><code><span class="constructor">CDCL</span></code></td></tr><tr id="type-sat_solver.CDCL_Tableaux" class="anchored"><td class="def constructor"><a href="#type-sat_solver.CDCL_Tableaux" class="anchor"></a><code>| </code><code><span class="constructor">CDCL_Tableaux</span></code></td></tr></table></dt><dt class="spec type" id="type-theories_extensions"><a href="#type-theories_extensions" class="anchor"></a><code><span class="keyword">type</span> theories_extensions</code><code> = </code><table class="variant"><tr id="type-theories_extensions.Sum" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.Sum" class="anchor"></a><code>| </code><code><span class="constructor">Sum</span></code></td></tr><tr id="type-theories_extensions.Adt" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.Adt" class="anchor"></a><code>| </code><code><span class="constructor">Adt</span></code></td></tr><tr id="type-theories_extensions.Arrays" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.Arrays" class="anchor"></a><code>| </code><code><span class="constructor">Arrays</span></code></td></tr><tr id="type-theories_extensions.Records" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.Records" class="anchor"></a><code>| </code><code><span class="constructor">Records</span></code></td></tr><tr id="type-theories_extensions.Bitv" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.Bitv" class="anchor"></a><code>| </code><code><span class="constructor">Bitv</span></code></td></tr><tr id="type-theories_extensions.LIA" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.LIA" class="anchor"></a><code>| </code><code><span class="constructor">LIA</span></code></td></tr><tr id="type-theories_extensions.LRA" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.LRA" class="anchor"></a><code>| </code><code><span class="constructor">LRA</span></code></td></tr><tr id="type-theories_extensions.NRA" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.NRA" class="anchor"></a><code>| </code><code><span class="constructor">NRA</span></code></td></tr><tr id="type-theories_extensions.NIA" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.NIA" class="anchor"></a><code>| </code><code><span class="constructor">NIA</span></code></td></tr><tr id="type-theories_extensions.FPA" class="anchored"><td class="def constructor"><a href="#type-theories_extensions.FPA" class="anchor"></a><code>| </code><code><span class="constructor">FPA</span></code></td></tr></table></dt><dt class="spec type" id="type-axiom_kind"><a href="#type-axiom_kind" class="anchor"></a><code><span class="keyword">type</span> axiom_kind</code><code> = </code><table class="variant"><tr id="type-axiom_kind.Default" class="anchored"><td class="def constructor"><a href="#type-axiom_kind.Default" class="anchor"></a><code>| </code><code><span class="constructor">Default</span></code></td></tr><tr id="type-axiom_kind.Propagator" class="anchored"><td class="def constructor"><a href="#type-axiom_kind.Propagator" class="anchor"></a><code>| </code><code><span class="constructor">Propagator</span></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-th_ext_of_string"><a href="#val-th_ext_of_string" class="anchor"></a><code><span class="keyword">val</span> th_ext_of_string : string <span>&#45;&gt;</span> <span><a href="index.html#type-theories_extensions">theories_extensions</a> option</span></code></dt><dt class="spec value" id="val-string_of_th_ext"><a href="#val-string_of_th_ext" class="anchor"></a><code><span class="keyword">val</span> string_of_th_ext : <a href="index.html#type-theories_extensions">theories_extensions</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-compare_algebraic"><a href="#val-compare_algebraic" class="anchor"></a><code><span class="keyword">val</span> compare_algebraic : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> int</code></dt><dd><p>generic function for comparing algebraic data types. <code>compare_algebraic a b f</code></p><ul><li>Stdlib.compare a b is used if</li></ul></dd></dl><dl><dt class="spec value" id="val-cmp_lists"><a href="#val-cmp_lists" class="anchor"></a><code><span class="keyword">val</span> cmp_lists : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> int</code></dt></dl><dl><dt class="spec type" id="type-matching_env"><a href="#type-matching_env" class="anchor"></a><code><span class="keyword">type</span> matching_env</code><code> = </code><code>{</code><table class="record"><tr id="type-matching_env.nb_triggers" class="anchored"><td class="def field"><a href="#type-matching_env.nb_triggers" class="anchor"></a><code>nb_triggers : int;</code></td></tr><tr id="type-matching_env.triggers_var" class="anchored"><td class="def field"><a href="#type-matching_env.triggers_var" class="anchor"></a><code>triggers_var : bool;</code></td></tr><tr id="type-matching_env.no_ematching" class="anchored"><td class="def field"><a href="#type-matching_env.no_ematching" class="anchor"></a><code>no_ematching : bool;</code></td></tr><tr id="type-matching_env.greedy" class="anchored"><td class="def field"><a href="#type-matching_env.greedy" class="anchor"></a><code>greedy : bool;</code></td></tr><tr id="type-matching_env.use_cs" class="anchored"><td class="def field"><a href="#type-matching_env.use_cs" class="anchor"></a><code>use_cs : bool;</code></td></tr><tr id="type-matching_env.backward" class="anchored"><td class="def field"><a href="#type-matching_env.backward" class="anchor"></a><code>backward : <a href="index.html#type-inst_kind">inst_kind</a>;</code></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-loop"><a href="#val-loop" class="anchor"></a><code><span class="keyword">val</span> loop : <span>f:<span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span></span> <span>&#45;&gt;</span> <span>max:int</span> <span>&#45;&gt;</span> <span>elt:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Loops from 0 to <code>max</code> and returns <code>(f max elt ... (f 1 elt (f 0 elt init)))...)</code>. Returns <code>init</code> if <code>max</code> &lt; 0</p></dd></dl><dl><dt class="spec value" id="val-print_list"><a href="#val-print_list" class="anchor"></a><code><span class="keyword">val</span> print_list : <span>sep:string</span> <span>&#45;&gt;</span> <span>pp:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_list_pp"><a href="#val-print_list_pp" class="anchor"></a><code><span class="keyword">val</span> print_list_pp : <span>sep:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>pp:<span>(Stdlib.Format.formatter <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> unit</code></dt></dl></div></body></html>