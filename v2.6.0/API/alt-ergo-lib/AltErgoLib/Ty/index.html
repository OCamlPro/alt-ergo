<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ty (alt-ergo-lib.AltErgoLib.Ty)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../index.html">AltErgoLib</a> &#x00BB; Ty</nav><header class="odoc-preamble"><h1>Module <code><span>AltErgoLib.Ty</span></code></h1><p>Types</p><p>This module defines the representation of types.</p></header><nav class="odoc-toc"><ul><li><a href="#definition">Definition</a></li><li><a href="#type-inspection">Type inspection</a></li><li><a href="#building-types">Building types</a></li><li><a href="#substitutions">Substitutions</a></li><li><a href="#unification/matching">Unification/Matching</a></li><li><a href="#manipulations-on-types">Manipulations on types</a></li></ul></nav><div class="odoc-content"><h3 id="definition"><a href="#definition" class="anchor"></a>Definition</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span></code><ol><li id="type-t.Tint" class="def variant constructor anchored"><a href="#type-t.Tint" class="anchor"></a><code><span>| </span><span><span class="constructor">Tint</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer numbers</p><span class="comment-delim">*)</span></div></li><li id="type-t.Treal" class="def variant constructor anchored"><a href="#type-t.Treal" class="anchor"></a><code><span>| </span><span><span class="constructor">Treal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Real numbers</p><span class="comment-delim">*)</span></div></li><li id="type-t.Tbool" class="def variant constructor anchored"><a href="#type-t.Tbool" class="anchor"></a><code><span>| </span><span><span class="constructor">Tbool</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Booleans</p><span class="comment-delim">*)</span></div></li><li id="type-t.Tvar" class="def variant constructor anchored"><a href="#type-t.Tvar" class="anchor"></a><code><span>| </span><span><span class="constructor">Tvar</span> <span class="keyword">of</span> <a href="#type-tvar">tvar</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Type variables</p><span class="comment-delim">*)</span></div></li><li id="type-t.Tbitv" class="def variant constructor anchored"><a href="#type-t.Tbitv" class="anchor"></a><code><span>| </span><span><span class="constructor">Tbitv</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvectors of a given length</p><span class="comment-delim">*)</span></div></li><li id="type-t.Text" class="def variant constructor anchored"><a href="#type-t.Text" class="anchor"></a><code><span>| </span><span><span class="constructor">Text</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span> * <a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Abstract types applied to arguments. <code>Text (args, s)</code> is the application of the abstract type constructor <code>s</code> to arguments <code>args</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Tfarray" class="def variant constructor anchored"><a href="#type-t.Tfarray" class="anchor"></a><code><span>| </span><span><span class="constructor">Tfarray</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Functional arrays. <code>TFarray (src,dst)</code> maps values of type <code>src</code> to values of type <code>dst</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Tadt" class="def variant constructor anchored"><a href="#type-t.Tadt" class="anchor"></a><code><span>| </span><span><span class="constructor">Tadt</span> <span class="keyword">of</span> <a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a> * <span><a href="#type-t">t</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Application of algebraic data types. <code>Tadt (a, params)</code> denotes the application of the polymorphic datatype <code>a</code> to the types parameters <code>params</code>.</p><p>For instance the type of integer lists can be represented by the value <code>Tadt (Hstring.make &quot;list&quot;, [Tint]</code> where the identifier <em>list</em> denotes a polymorphic ADT defined by the user with <code>t_adt</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-t.Trecord" class="def variant constructor anchored"><a href="#type-t.Trecord" class="anchor"></a><code><span>| </span><span><span class="constructor">Trecord</span> <span class="keyword">of</span> <a href="#type-trecord">trecord</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record type.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tvar"><a href="#type-tvar" class="anchor"></a><code><span><span class="keyword">and</span> tvar</span><span> = </span><span>{</span></code><ol><li id="type-tvar.v" class="def record field anchored"><a href="#type-tvar.v" class="anchor"></a><code><span>v : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unique identifier</p><span class="comment-delim">*)</span></div></li><li id="type-tvar.value" class="def record field anchored"><a href="#type-tvar.value" class="anchor"></a><code><span><span class="keyword">mutable</span> value : <span><a href="#type-t">t</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pointer to the current value of the type variable.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type variables. The <code>value</code> field is mutated during unification, hence distinct types should have disjoints sets of type variables (see function <a href="#val-fresh"><code>fresh</code></a>).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-trecord"><a href="#type-trecord" class="anchor"></a><code><span><span class="keyword">and</span> trecord</span><span> = </span><span>{</span></code><ol><li id="type-trecord.args" class="def record field anchored"><a href="#type-trecord.args" class="anchor"></a><code><span><span class="keyword">mutable</span> args : <span><a href="#type-t">t</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arguments passed to the record constructor</p><span class="comment-delim">*)</span></div></li><li id="type-trecord.name" class="def record field anchored"><a href="#type-trecord.name" class="anchor"></a><code><span>name : <a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Name of the record type</p><span class="comment-delim">*)</span></div></li><li id="type-trecord.lbs" class="def record field anchored"><a href="#type-trecord.lbs" class="anchor"></a><code><span><span class="keyword">mutable</span> lbs : <span><span>(<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <a href="#type-t">t</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List of fields of the record. Each field has a name, and an associated type.</p><span class="comment-delim">*)</span></div></li><li id="type-trecord.record_constr" class="def record field anchored"><a href="#type-trecord.record_constr" class="anchor"></a><code><span>record_constr : <a href="../Uid/index.html#type-term_cst">Uid.term_cst</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>record constructor. Useful is case it's a specialization of an algeberaic datatype. Default value is &quot;{__<code>name</code>&quot;</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Record types.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-adt_constr"><a href="#type-adt_constr" class="anchor"></a><code><span><span class="keyword">type</span> adt_constr</span><span> = </span><span>{</span></code><ol><li id="type-adt_constr.constr" class="def record field anchored"><a href="#type-adt_constr.constr" class="anchor"></a><code><span>constr : <a href="../Uid/index.html#type-term_cst">Uid.term_cst</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>constructor of an ADT type</p><span class="comment-delim">*)</span></div></li><li id="type-adt_constr.destrs" class="def record field anchored"><a href="#type-adt_constr.destrs" class="anchor"></a><code><span>destrs : <span><span>(<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <a href="#type-t">t</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>the list of destructors associated with the constructor and their respective types</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-type_body"><a href="#type-type_body" class="anchor"></a><code><span><span class="keyword">type</span> type_body</span><span> = <span><a href="#type-adt_constr">adt_constr</a> list</span></span></code></div><div class="spec-doc"><p>Bodies of types definitions. Currently, bodies are inlined in the type <code>t</code> for records and enumerations. But, this is not possible for recursive ADTs</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Svty"><a href="#module-Svty" class="anchor"></a><code><span><span class="keyword">module</span> Svty</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="xref-unresolved">int</span></span></span></code></div><div class="spec-doc"><p>Sets of type variables, indexed by their identifier.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> Set</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="xref-unresolved">t</span></span></span></code></div><div class="spec-doc"><p>Sets of types</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-assoc_destrs"><a href="#val-assoc_destrs" class="anchor"></a><code><span><span class="keyword">val</span> assoc_destrs : <span><a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-adt_constr">adt_constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <a href="#type-t">t</a>)</span> list</span></span></code></div><div class="spec-doc"><p><code>assoc_destrs cons cases</code> returns the list of destructors associated with the constructor <code>cons</code> in the ADT defined by <code>cases</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the constructor is not in the given list.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_body"><a href="#val-type_body" class="anchor"></a><code><span><span class="keyword">val</span> type_body : <span><a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-type_body">type_body</a></span></code></div></div><h3 id="type-inspection"><a href="#type-inspection" class="anchor"></a>Type inspection</h3><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Hash function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Comparison function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_smtlib"><a href="#val-pp_smtlib" class="anchor"></a><code><span><span class="keyword">val</span> pp_smtlib : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Printing function for types in smtlib2 format.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Printing function for types (does not print the type of each fields for records).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_list"><a href="#val-print_list" class="anchor"></a><code><span><span class="keyword">val</span> print_list : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print function for lists of types (does not print the type of each fields for records).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_full"><a href="#val-print_full" class="anchor"></a><code><span><span class="keyword">val</span> print_full : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print function including the record fields.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vty_of"><a href="#val-vty_of" class="anchor"></a><code><span><span class="keyword">val</span> vty_of : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Svty</span>.t</span></code></div><div class="spec-doc"><p>Returns the set of type variables that occur in a given type.</p></div></div><h3 id="building-types"><a href="#building-types" class="anchor"></a>Building types</h3><div class="odoc-spec"><div class="spec value anchored" id="val-tunit"><a href="#val-tunit" class="anchor"></a><code><span><span class="keyword">val</span> tunit : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The unit type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_var"><a href="#val-fresh_var" class="anchor"></a><code><span><span class="keyword">val</span> fresh_var : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-tvar">tvar</a></span></code></div><div class="spec-doc"><p>Generate a fresh type variable, guaranteed to be distinct from any other previously generated by this function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_tvar"><a href="#val-fresh_tvar" class="anchor"></a><code><span><span class="keyword">val</span> fresh_tvar : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Wrap the <a href="#val-fresh_var"><code>fresh_var</code></a> function to return a type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_empty_text"><a href="#val-fresh_empty_text" class="anchor"></a><code><span><span class="keyword">val</span> fresh_empty_text : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return a fesh abstract type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-text"><a href="#val-text" class="anchor"></a><code><span><span class="keyword">val</span> text : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Apply the abstract type constructor to the list of type arguments given.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_adt"><a href="#val-t_adt" class="anchor"></a><code><span><span class="keyword">val</span> t_adt : 
  <span><span class="optlabel">?body</span>:<span><span><span>(<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <span><span>(<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <a href="#type-t">t</a>)</span> list</span>)</span> list</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an algebraic datatype. The body is a list of constructors, where each constructor is associated with the list of its destructors with their respective types. If <code>body</code> is none, then no definition will be registered for this type. The second argument is the name of the type. The third one provides its list of arguments.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trecord"><a href="#val-trecord" class="anchor"></a><code><span><span class="keyword">val</span> trecord : 
  <span><span class="optlabel">?sort_fields</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">record_constr</span>:<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Uid/index.html#type-ty_cst">Uid.ty_cst</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a record type. <code>trecord args name lbs</code> creates a record type with name <code>name</code>, arguments <code>args</code> and fields <code>lbs</code>.</p><p>If <code>sort_fields</code> is true, the record fields are sorted according to <code>Hstring.compare</code>. This is to preserve compatibility with the old typechecker behavior and should not be used in new code.</p></div></div><h3 id="substitutions"><a href="#substitutions" class="anchor"></a>Substitutions</h3><div class="odoc-spec"><div class="spec module anchored" id="module-M"><a href="#module-M" class="anchor"></a><code><span><span class="keyword">module</span> M</span><span> : <span class="xref-unresolved">Stdlib</span>.Map.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">key</span> = <span class="xref-unresolved">int</span></span></span></code></div><div class="spec-doc"><p>Maps from type variables identifiers.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-subst"><a href="#type-subst" class="anchor"></a><code><span><span class="keyword">type</span> subst</span><span> = <span><a href="#type-t">t</a> <span class="xref-unresolved">M</span>.t</span></span></code></div><div class="spec-doc"><p>The type of substitution, i.e. maps from type variables identifiers to types.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_subst"><a href="#val-compare_subst" class="anchor"></a><code><span><span class="keyword">val</span> compare_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Comparison of substitutions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_subst"><a href="#val-equal_subst" class="anchor"></a><code><span><span class="keyword">val</span> equal_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality of substitutions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_subst"><a href="#val-print_subst" class="anchor"></a><code><span><span class="keyword">val</span> print_subst : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print function for substitutions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-esubst"><a href="#val-esubst" class="anchor"></a><code><span><span class="keyword">val</span> esubst : <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>The empty substitution, a.k.a. the identity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_subst"><a href="#val-apply_subst" class="anchor"></a><code><span><span class="keyword">val</span> apply_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Substitution application.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union_subst"><a href="#val-union_subst" class="anchor"></a><code><span><span class="keyword">val</span> union_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p><code>union_subst u v</code> applies <code>v</code> to <code>u</code>, resulting in <code>u'</code>. It then computes the union of <code>u'</code> and <code>v</code>, prioritizing bindings from <code>u'</code> in case of conflict.</p></div></div><h3 id="unification/matching"><a href="#unification/matching" class="anchor"></a>Unification/Matching</h3><div class="odoc-spec"><div class="spec exception anchored" id="exception-TypeClash"><a href="#exception-TypeClash" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">TypeClash</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Exception raised during matching or unification. <code>TypeClash (u, v)</code> is raised when <code>u</code> and <code>v</code> could not be matched or unified (<code>u</code> and <code>v</code> may be sub-types of the types being actually unified or matched).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span><span class="keyword">val</span> unify : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Destructive unification. Mutates the <code>value</code> fields of type variables.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-TypeClash"><code>TypeClash</code></a> <p>when unification is impossible. In this case, the <code>value</code> fields of already mutated type variables are left modified, which may prevent future unifications.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matching"><a href="#val-matching" class="anchor"></a><code><span><span class="keyword">val</span> matching : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>Matching of types (non-destructive). <code>matching pat t</code> returns a substitution <code>subst</code> such that <code>apply_subst subst pat</code> is equal to <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shorten"><a href="#val-shorten" class="anchor"></a><code><span><span class="keyword">val</span> shorten : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Shorten paths in type variables values. Unification in particular can create chains where the <code>value</code> field of one type variable points to another and so on... This function short-circuits such chains so that the value of a type variable can be accessed directly.</p></div></div><h3 id="manipulations-on-types"><a href="#manipulations-on-types" class="anchor"></a>Manipulations on types</h3><div class="odoc-spec"><div class="spec value anchored" id="val-fresh"><a href="#val-fresh" class="anchor"></a><code><span><span class="keyword">val</span> fresh : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>Apply the given substitution, all while generating fresh variables for the variables not already bound in the substitution. Returns a substitution containing bindings from old variable to their fresh counterpart.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_list"><a href="#val-fresh_list" class="anchor"></a><code><span><span class="keyword">val</span> fresh_list : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span> * <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-fresh"><code>fresh</code></a> but on lists of types.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-instantiate"><a href="#val-instantiate" class="anchor"></a><code><span><span class="keyword">val</span> instantiate : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>instantiate vars args t</code> builds the substitutions mapping each type variable in <code>vars</code> to the corresponding term in <code>args</code>, then apply that substitution to <code>t</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the lists <code>vars</code> and <code>args</code> do not have the same length</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Assertion_failure</code> <p>if one type in <code>vars</code> is not a type variable.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-monomorphize"><a href="#val-monomorphize" class="anchor"></a><code><span><span class="keyword">val</span> monomorphize : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return a monomorphized variant of the given type, where type variable without values have been replaced by abstract types.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-goal_sort"><a href="#type-goal_sort" class="anchor"></a><code><span><span class="keyword">type</span> goal_sort</span><span> = </span></code><ol><li id="type-goal_sort.Cut" class="def variant constructor anchored"><a href="#type-goal_sort.Cut" class="anchor"></a><code><span>| </span><span><span class="constructor">Cut</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Introduce a cut in a goal. Once the cut proved, it's added as a hypothesis.</p><span class="comment-delim">*)</span></div></li><li id="type-goal_sort.Check" class="def variant constructor anchored"><a href="#type-goal_sort.Check" class="anchor"></a><code><span>| </span><span><span class="constructor">Check</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Check if some intermediate assertion is prouvable</p><span class="comment-delim">*)</span></div></li><li id="type-goal_sort.Thm" class="def variant constructor anchored"><a href="#type-goal_sort.Thm" class="anchor"></a><code><span>| </span><span><span class="constructor">Thm</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The goal to be proved valid</p><span class="comment-delim">*)</span></div></li><li id="type-goal_sort.Sat" class="def variant constructor anchored"><a href="#type-goal_sort.Sat" class="anchor"></a><code><span>| </span><span><span class="constructor">Sat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The goal to be proved satisfiable</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Goal sort. Used in typed declarations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_hypothesis_name"><a href="#val-fresh_hypothesis_name" class="anchor"></a><code><span><span class="keyword">val</span> fresh_hypothesis_name : <span><a href="#type-goal_sort">goal_sort</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>create a fresh hypothesis name given a goal sort.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_local_hyp"><a href="#val-is_local_hyp" class="anchor"></a><code><span><span class="keyword">val</span> is_local_hyp : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Assuming a name generated by <a href="#val-fresh_hypothesis_name"><code>fresh_hypothesis_name</code></a>, answers whether the name design a local hypothesis ?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_global_hyp"><a href="#val-is_global_hyp" class="anchor"></a><code><span><span class="keyword">val</span> is_global_hyp : <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Assuming a name generated by <a href="#val-fresh_hypothesis_name"><code>fresh_hypothesis_name</code></a>, does the name design a global hypothesis ?</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_goal_sort"><a href="#val-print_goal_sort" class="anchor"></a><code><span><span class="keyword">val</span> print_goal_sort : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-goal_sort">goal_sort</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print a goal sort</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reinit_decls"><a href="#val-reinit_decls" class="anchor"></a><code><span><span class="keyword">val</span> reinit_decls : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Empties the decls cache</p></div></div></div></body></html>
