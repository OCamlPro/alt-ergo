<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Typed (alt-ergo-lib.AltErgoLib.Typed)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../index.html">AltErgoLib</a> &#x00BB; Typed</nav><header class="odoc-preamble"><h1>Module <code><span>AltErgoLib.Typed</span></code></h1><p>Typed AST</p><p>This module defines a typed AST, used to represent typed terms before they are hashconsed.</p></header><nav class="odoc-toc"><ul><li><a href="#annotations">Annotations</a></li><li><a href="#terms-and-formulas">Terms and formulas</a></li><li><a href="#declarations">Declarations</a><ul><li><a href="#printing">Printing</a></li></ul></li></ul></nav><div class="odoc-content"><h3 id="annotations"><a href="#annotations" class="anchor"></a>Annotations</h3><div class="odoc-spec"><div class="spec type anchored" id="type-annoted"><a href="#type-annoted" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) annoted</span></span><span> = </span><span>{</span></code><ol><li id="type-annoted.c" class="def record field anchored"><a href="#type-annoted.c" class="anchor"></a><code><span>c : <span class="type-var">'a</span>;</span></code></li><li id="type-annoted.annot" class="def record field anchored"><a href="#type-annoted.annot" class="anchor"></a><code><span>annot : <span class="type-var">'b</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>An annoted structure. Usually used to annotate terms.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-new_id"><a href="#val-new_id" class="anchor"></a><code><span><span class="keyword">val</span> new_id : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Generate a new, fresh integer (useful for annotations).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk"><a href="#val-mk" class="anchor"></a><code><span><span class="keyword">val</span> mk : <span><span class="optlabel">?annot</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, int)</span> <a href="#type-annoted">annoted</a></span></span></code></div><div class="spec-doc"><p>Create an annoted value with the given annotation. If no annotation is given, a fresh annotation is generated using <a href="#val-new_id"><code>new_id</code></a>.</p></div></div><h3 id="terms-and-formulas"><a href="#terms-and-formulas" class="anchor"></a>Terms and formulas</h3><div class="odoc-spec"><div class="spec type anchored" id="type-tconstant"><a href="#type-tconstant" class="anchor"></a><code><span><span class="keyword">type</span> tconstant</span><span> = </span></code><ol><li id="type-tconstant.Tint" class="def variant constructor anchored"><a href="#type-tconstant.Tint" class="anchor"></a><code><span>| </span><span><span class="constructor">Tint</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An integer constant.</p><span class="comment-delim">*)</span></div></li><li id="type-tconstant.Treal" class="def variant constructor anchored"><a href="#type-tconstant.Treal" class="anchor"></a><code><span>| </span><span><span class="constructor">Treal</span> <span class="keyword">of</span> <a href="../Numbers/Q/index.html#type-t">Numbers.Q.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Real constant.</p><span class="comment-delim">*)</span></div></li><li id="type-tconstant.Tbitv" class="def variant constructor anchored"><a href="#type-tconstant.Tbitv" class="anchor"></a><code><span>| </span><span><span class="constructor">Tbitv</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bitvector constant.</p><span class="comment-delim">*)</span></div></li><li id="type-tconstant.Ttrue" class="def variant constructor anchored"><a href="#type-tconstant.Ttrue" class="anchor"></a><code><span>| </span><span><span class="constructor">Ttrue</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The true boolean (or proposition ?)</p><span class="comment-delim">*)</span></div></li><li id="type-tconstant.Tfalse" class="def variant constructor anchored"><a href="#type-tconstant.Tfalse" class="anchor"></a><code><span>| </span><span><span class="constructor">Tfalse</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The false boolean</p><span class="comment-delim">*)</span></div></li><li id="type-tconstant.Tvoid" class="def variant constructor anchored"><a href="#type-tconstant.Tvoid" class="anchor"></a><code><span>| </span><span><span class="constructor">Tvoid</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The only value of type unit</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Typed constants.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-oplogic"><a href="#type-oplogic" class="anchor"></a><code><span><span class="keyword">type</span> oplogic</span><span> = </span></code><ol><li id="type-oplogic.OPand" class="def variant constructor anchored"><a href="#type-oplogic.OPand" class="anchor"></a><code><span>| </span><span><span class="constructor">OPand</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>conjunction</p><span class="comment-delim">*)</span></div></li><li id="type-oplogic.OPor" class="def variant constructor anchored"><a href="#type-oplogic.OPor" class="anchor"></a><code><span>| </span><span><span class="constructor">OPor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>disjunction</p><span class="comment-delim">*)</span></div></li><li id="type-oplogic.OPxor" class="def variant constructor anchored"><a href="#type-oplogic.OPxor" class="anchor"></a><code><span>| </span><span><span class="constructor">OPxor</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>exclusive disjunction</p><span class="comment-delim">*)</span></div></li><li id="type-oplogic.OPimp" class="def variant constructor anchored"><a href="#type-oplogic.OPimp" class="anchor"></a><code><span>| </span><span><span class="constructor">OPimp</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>implication</p><span class="comment-delim">*)</span></div></li><li id="type-oplogic.OPnot" class="def variant constructor anchored"><a href="#type-oplogic.OPnot" class="anchor"></a><code><span>| </span><span><span class="constructor">OPnot</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>negation</p><span class="comment-delim">*)</span></div></li><li id="type-oplogic.OPiff" class="def variant constructor anchored"><a href="#type-oplogic.OPiff" class="anchor"></a><code><span>| </span><span><span class="constructor">OPiff</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>equivalence</p><span class="comment-delim">*)</span></div></li><li id="type-oplogic.OPif" class="def variant constructor anchored"><a href="#type-oplogic.OPif" class="anchor"></a><code><span>| </span><span><span class="constructor">OPif</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>conditional branching</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Logic operators.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">type</span> pattern</span><span> = </span></code><ol><li id="type-pattern.Constr" class="def variant constructor anchored"><a href="#type-pattern.Constr" class="anchor"></a><code><span>| </span><span><span class="constructor">Constr</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-pattern.name" class="def record field anchored"><a href="#type-pattern.name" class="anchor"></a><code><span>name : <a href="../Uid/index.html#type-term_cst">Uid.term_cst</a>;</span></code></li><li id="type-pattern.args" class="def record field anchored"><a href="#type-pattern.args" class="anchor"></a><code><span>args : <span><span>(<a href="../Var/index.html#type-t">Var.t</a> * <a href="../Uid/index.html#type-term_cst">Uid.term_cst</a> * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span>;</span></code></li></ol><code><span>}</span></code></li><li id="type-pattern.Var" class="def variant constructor anchored"><a href="#type-pattern.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="../Var/index.html#type-t">Var.t</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tterm"><a href="#type-tterm" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tterm</span></span><span> = </span><span>{</span></code><ol><li id="type-tterm.tt_ty" class="def record field anchored"><a href="#type-tterm.tt_ty" class="anchor"></a><code><span>tt_ty : <a href="../Ty/index.html#type-t">Ty.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>type of the term</p><span class="comment-delim">*)</span></div></li><li id="type-tterm.tt_desc" class="def record field anchored"><a href="#type-tterm.tt_desc" class="anchor"></a><code><span>tt_desc : <span><span class="type-var">'a</span> <a href="#type-tt_desc">tt_desc</a></span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>term descriptor</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Typed terms. Polymorphic in the annotation: an <code>'a tterm</code> is a term annoted with values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-atterm"><a href="#type-atterm" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a atterm</span></span><span> = <span><span>(<span><span class="type-var">'a</span> <a href="#type-tterm">tterm</a></span>, <span class="type-var">'a</span>)</span> <a href="#type-annoted">annoted</a></span></span></code></div><div class="spec-doc"><p>type alias for annoted typed terms.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tt_desc"><a href="#type-tt_desc" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a tt_desc</span></span><span> = </span></code><ol><li id="type-tt_desc.TTconst" class="def variant constructor anchored"><a href="#type-tt_desc.TTconst" class="anchor"></a><code><span>| </span><span><span class="constructor">TTconst</span> <span class="keyword">of</span> <a href="#type-tconstant">tconstant</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Term constant</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTvar" class="def variant constructor anchored"><a href="#type-tt_desc.TTvar" class="anchor"></a><code><span>| </span><span><span class="constructor">TTvar</span> <span class="keyword">of</span> <a href="../Symbols/index.html#type-t">Symbols.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Term variables</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTinfix" class="def variant constructor anchored"><a href="#type-tt_desc.TTinfix" class="anchor"></a><code><span>| </span><span><span class="constructor">TTinfix</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <a href="../Symbols/index.html#type-t">Symbols.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Infix symbol application</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTprefix" class="def variant constructor anchored"><a href="#type-tt_desc.TTprefix" class="anchor"></a><code><span>| </span><span><span class="constructor">TTprefix</span> <span class="keyword">of</span> <a href="../Symbols/index.html#type-t">Symbols.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Prefix symbol application</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTapp" class="def variant constructor anchored"><a href="#type-tt_desc.TTapp" class="anchor"></a><code><span>| </span><span><span class="constructor">TTapp</span> <span class="keyword">of</span> <a href="../Symbols/index.html#type-t">Symbols.t</a> * <span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arbitrary symbol application</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTmapsTo" class="def variant constructor anchored"><a href="#type-tt_desc.TTmapsTo" class="anchor"></a><code><span>| </span><span><span class="constructor">TTmapsTo</span> <span class="keyword">of</span> <a href="../Var/index.html#type-t">Var.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Used in semantic triggers for floating point arithmetic. See sources/preludes/fpa-theory-2017-01-04-16h00.ae</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTinInterval" class="def variant constructor anchored"><a href="#type-tt_desc.TTinInterval" class="anchor"></a><code><span>| </span><span><span class="constructor">TTinInterval</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <a href="../Symbols/index.html#type-bound">Symbols.bound</a> * <a href="../Symbols/index.html#type-bound">Symbols.bound</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Represent floating point intervals (used for triggers in Floating point arithmetic theory). <code>TTinInterval (lower, l_strict, t, upper, u_strict)</code> is a constraint stating that term <code>t</code> is in the interval <code>lower, upper</code>, and that the lower (resp. upper) bound is strict iff <code>l_strict</code> (resp. <code>u_strict</code>) is true.</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTget" class="def variant constructor anchored"><a href="#type-tt_desc.TTget" class="anchor"></a><code><span>| </span><span><span class="constructor">TTget</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Get operation on arrays</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTset" class="def variant constructor anchored"><a href="#type-tt_desc.TTset" class="anchor"></a><code><span>| </span><span><span class="constructor">TTset</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Set operation on arrays</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTextract" class="def variant constructor anchored"><a href="#type-tt_desc.TTextract" class="anchor"></a><code><span>| </span><span><span class="constructor">TTextract</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Extract a sub-bitvector</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTconcat" class="def variant constructor anchored"><a href="#type-tt_desc.TTconcat" class="anchor"></a><code><span>| </span><span><span class="constructor">TTconcat</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code></li><li id="type-tt_desc.TTdot" class="def variant constructor anchored"><a href="#type-tt_desc.TTdot" class="anchor"></a><code><span>| </span><span><span class="constructor">TTdot</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <a href="../Hstring/index.html#type-t">Hstring.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Field access on structs/records</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTrecord" class="def variant constructor anchored"><a href="#type-tt_desc.TTrecord" class="anchor"></a><code><span>| </span><span><span class="constructor">TTrecord</span> <span class="keyword">of</span> <span><span>(<a href="../Hstring/index.html#type-t">Hstring.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record creation.</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTlet" class="def variant constructor anchored"><a href="#type-tt_desc.TTlet" class="anchor"></a><code><span>| </span><span><span class="constructor">TTlet</span> <span class="keyword">of</span> <span><span>(<a href="../Symbols/index.html#type-t">Symbols.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span>)</span> list</span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let-bindings. Accept a list of mutually recursive le-bindings.</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTnamed" class="def variant constructor anchored"><a href="#type-tt_desc.TTnamed" class="anchor"></a><code><span>| </span><span><span class="constructor">TTnamed</span> <span class="keyword">of</span> <a href="../Hstring/index.html#type-t">Hstring.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Attach a label to a term.</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTite" class="def variant constructor anchored"><a href="#type-tt_desc.TTite" class="anchor"></a><code><span>| </span><span><span class="constructor">TTite</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Conditional branching, of the form <code>TTite (condition, then_branch, else_branch)</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTproject" class="def variant constructor anchored"><a href="#type-tt_desc.TTproject" class="anchor"></a><code><span>| </span><span><span class="constructor">TTproject</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <a href="../Hstring/index.html#type-t">Hstring.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Field (conditional) access on ADTs.</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTmatch" class="def variant constructor anchored"><a href="#type-tt_desc.TTmatch" class="anchor"></a><code><span>| </span><span><span class="constructor">TTmatch</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span>(<a href="#type-pattern">pattern</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>pattern matching on ADTs</p><span class="comment-delim">*)</span></div></li><li id="type-tt_desc.TTform" class="def variant constructor anchored"><a href="#type-tt_desc.TTform" class="anchor"></a><code><span>| </span><span><span class="constructor">TTform</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>formulas inside terms: simple way to add them without making a lot of changes</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Typed terms descriptors.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-atatom"><a href="#type-atatom" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a atatom</span></span><span> = <span><span>(<span><span class="type-var">'a</span> <a href="#type-tatom">tatom</a></span>, <span class="type-var">'a</span>)</span> <a href="#type-annoted">annoted</a></span></span></code></div><div class="spec-doc"><p>Type alias for annoted typed atoms.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tatom"><a href="#type-tatom" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a tatom</span></span><span> = </span></code><ol><li id="type-tatom.TAtrue" class="def variant constructor anchored"><a href="#type-tatom.TAtrue" class="anchor"></a><code><span>| </span><span><span class="constructor">TAtrue</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The <code>true</code> atom</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TAfalse" class="def variant constructor anchored"><a href="#type-tatom.TAfalse" class="anchor"></a><code><span>| </span><span><span class="constructor">TAfalse</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The <code>false</code> atom</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TAeq" class="def variant constructor anchored"><a href="#type-tatom.TAeq" class="anchor"></a><code><span>| </span><span><span class="constructor">TAeq</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality of a set of typed terms.</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TAdistinct" class="def variant constructor anchored"><a href="#type-tatom.TAdistinct" class="anchor"></a><code><span>| </span><span><span class="constructor">TAdistinct</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Disequality. All terms in the set are pairwise distinct.</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TAneq" class="def variant constructor anchored"><a href="#type-tatom.TAneq" class="anchor"></a><code><span>| </span><span><span class="constructor">TAneq</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality negation: at least two elements in the list are not equal.</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TAle" class="def variant constructor anchored"><a href="#type-tatom.TAle" class="anchor"></a><code><span>| </span><span><span class="constructor">TAle</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arithmetic ordering: lesser or equal. Chained on lists of terms.</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TAlt" class="def variant constructor anchored"><a href="#type-tatom.TAlt" class="anchor"></a><code><span>| </span><span><span class="constructor">TAlt</span> <span class="keyword">of</span> <span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Strict arithmetic ordering: less than. Chained on lists of terms.</p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TApred" class="def variant constructor anchored"><a href="#type-tatom.TApred" class="anchor"></a><code><span>| </span><span><span class="constructor">TApred</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Term predicate, negated if the boolean is true. <code>TApred (t, negated)</code> is satisfied iff <code>t &lt;=&gt; not negated</code></p><span class="comment-delim">*)</span></div></li><li id="type-tatom.TTisConstr" class="def variant constructor anchored"><a href="#type-tatom.TTisConstr" class="anchor"></a><code><span>| </span><span><span class="constructor">TTisConstr</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <a href="../Hstring/index.html#type-t">Hstring.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Test if the given term's head symbol is identitical to the provided ADT consturctor</p><span class="comment-delim">*)</span></div></li></ol></div></div><p>Typed atoms.</p><div class="odoc-spec"><div class="spec type anchored" id="type-quant_form"><a href="#type-quant_form" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a quant_form</span></span><span> = </span><span>{</span></code><ol><li id="type-quant_form.qf_bvars" class="def record field anchored"><a href="#type-quant_form.qf_bvars" class="anchor"></a><code><span>qf_bvars : <span><span>(<a href="../Symbols/index.html#type-t">Symbols.t</a> * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variables that are quantified by this formula.</p><span class="comment-delim">*)</span></div></li><li id="type-quant_form.qf_triggers" class="def record field anchored"><a href="#type-quant_form.qf_triggers" class="anchor"></a><code><span>qf_triggers : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span> * bool)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Triggers associated wiht the formula. For each trigger, the boolean specifies whether the trigger was given in the input file (compared to inferred).</p><span class="comment-delim">*)</span></div></li><li id="type-quant_form.qf_hyp" class="def record field anchored"><a href="#type-quant_form.qf_hyp" class="anchor"></a><code><span>qf_hyp : <span><span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Hypotheses of axioms with semantic triggers in FPA theory. Typically, these hypotheses reduce to TRUE after instantiation</p><span class="comment-delim">*)</span></div></li><li id="type-quant_form.qf_form" class="def record field anchored"><a href="#type-quant_form.qf_form" class="anchor"></a><code><span>qf_form : <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The quantified formula.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Quantified formulas.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-atform"><a href="#type-atform" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a atform</span></span><span> = <span><span>(<span><span class="type-var">'a</span> <a href="#type-tform">tform</a></span>, <span class="type-var">'a</span>)</span> <a href="#type-annoted">annoted</a></span></span></code></div><div class="spec-doc"><p>Type alias for typed annoted formulas.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tform"><a href="#type-tform" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a tform</span></span><span> = </span></code><ol><li id="type-tform.TFatom" class="def variant constructor anchored"><a href="#type-tform.TFatom" class="anchor"></a><code><span>| </span><span><span class="constructor">TFatom</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atatom">atatom</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Atomic formula.</p><span class="comment-delim">*)</span></div></li><li id="type-tform.TFop" class="def variant constructor anchored"><a href="#type-tform.TFop" class="anchor"></a><code><span>| </span><span><span class="constructor">TFop</span> <span class="keyword">of</span> <a href="#type-oplogic">oplogic</a> * <span><span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Application of logical operators.</p><span class="comment-delim">*)</span></div></li><li id="type-tform.TFforall" class="def variant constructor anchored"><a href="#type-tform.TFforall" class="anchor"></a><code><span>| </span><span><span class="constructor">TFforall</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-quant_form">quant_form</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Universal quantification.</p><span class="comment-delim">*)</span></div></li><li id="type-tform.TFexists" class="def variant constructor anchored"><a href="#type-tform.TFexists" class="anchor"></a><code><span>| </span><span><span class="constructor">TFexists</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-quant_form">quant_form</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Existencial quantification.</p><span class="comment-delim">*)</span></div></li><li id="type-tform.TFlet" class="def variant constructor anchored"><a href="#type-tform.TFlet" class="anchor"></a><code><span>| </span><span><span class="constructor">TFlet</span> <span class="keyword">of</span> <span><span>(<a href="../Var/index.html#type-t">Var.t</a> * <span><span class="type-var">'a</span> <a href="#type-tlet_kind">tlet_kind</a></span>)</span> list</span> * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let binding.</p><span class="comment-delim">*)</span></div></li><li id="type-tform.TFnamed" class="def variant constructor anchored"><a href="#type-tform.TFnamed" class="anchor"></a><code><span>| </span><span><span class="constructor">TFnamed</span> <span class="keyword">of</span> <a href="../Hstring/index.html#type-t">Hstring.t</a> * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Attach a name to a formula.</p><span class="comment-delim">*)</span></div></li><li id="type-tform.TFmatch" class="def variant constructor anchored"><a href="#type-tform.TFmatch" class="anchor"></a><code><span>| </span><span><span class="constructor">TFmatch</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * <span><span>(<a href="#type-pattern">pattern</a> * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>pattern matching on ADTs</p><span class="comment-delim">*)</span></div></li></ol></div></div><p>Typed formulas.</p><div class="odoc-spec"><div class="spec type anchored" id="type-tlet_kind"><a href="#type-tlet_kind" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a tlet_kind</span></span><span> = </span></code><ol><li id="type-tlet_kind.TletTerm" class="def variant constructor anchored"><a href="#type-tlet_kind.TletTerm" class="anchor"></a><code><span>| </span><span><span class="constructor">TletTerm</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Term let-binding</p><span class="comment-delim">*)</span></div></li><li id="type-tlet_kind.TletForm" class="def variant constructor anchored"><a href="#type-tlet_kind.TletForm" class="anchor"></a><code><span>| </span><span><span class="constructor">TletForm</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Formula let-binding</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The different kinds of let-bindings, whether they bind terms or formulas.</p></div></div><h3 id="declarations"><a href="#declarations" class="anchor"></a>Declarations</h3><div class="odoc-spec"><div class="spec type anchored" id="type-rwt_rule"><a href="#type-rwt_rule" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a rwt_rule</span></span><span> = </span><span>{</span></code><ol><li id="type-rwt_rule.rwt_vars" class="def record field anchored"><a href="#type-rwt_rule.rwt_vars" class="anchor"></a><code><span>rwt_vars : <span><span>(<a href="../Symbols/index.html#type-t">Symbols.t</a> * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variables of the rewrite rule</p><span class="comment-delim">*)</span></div></li><li id="type-rwt_rule.rwt_left" class="def record field anchored"><a href="#type-rwt_rule.rwt_left" class="anchor"></a><code><span>rwt_left : <span class="type-var">'a</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Left side of the rewrite rule (aka pattern).</p><span class="comment-delim">*)</span></div></li><li id="type-rwt_rule.rwt_right" class="def record field anchored"><a href="#type-rwt_rule.rwt_right" class="anchor"></a><code><span>rwt_right : <span class="type-var">'a</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Right side of the rewrite rule.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Rewrite rules. Polymorphic to allow for different representation of terms.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tlogic_type"><a href="#type-tlogic_type" class="anchor"></a><code><span><span class="keyword">type</span> tlogic_type</span><span> = </span></code><ol><li id="type-tlogic_type.TPredicate" class="def variant constructor anchored"><a href="#type-tlogic_type.TPredicate" class="anchor"></a><code><span>| </span><span><span class="constructor">TPredicate</span> <span class="keyword">of</span> <span><a href="../Ty/index.html#type-t">Ty.t</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Predicate type declarations</p><span class="comment-delim">*)</span></div></li><li id="type-tlogic_type.TFunction" class="def variant constructor anchored"><a href="#type-tlogic_type.TFunction" class="anchor"></a><code><span>| </span><span><span class="constructor">TFunction</span> <span class="keyword">of</span> <span><a href="../Ty/index.html#type-t">Ty.t</a> list</span> * <a href="../Ty/index.html#type-t">Ty.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function type declarations</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type declarations. Specifies the list of argument types, as well as the return type for functions (predicate implicitly returns a proposition, so there is no need for an explicit return type).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-atdecl"><a href="#type-atdecl" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a atdecl</span></span><span> = <span><span>(<span><span class="type-var">'a</span> <a href="#type-tdecl">tdecl</a></span>, <span class="type-var">'a</span>)</span> <a href="#type-annoted">annoted</a></span></span></code></div><div class="spec-doc"><p>Type alias for annoted typed declarations.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tdecl"><a href="#type-tdecl" class="anchor"></a><code><span><span class="keyword">and</span> <span>'a tdecl</span></span><span> = </span></code><ol><li id="type-tdecl.TTheory" class="def variant constructor anchored"><a href="#type-tdecl.TTheory" class="anchor"></a><code><span>| </span><span><span class="constructor">TTheory</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * string * <a href="../Util/index.html#type-theories_extensions">Util.theories_extensions</a> * <span><span><span class="type-var">'a</span> <a href="#type-atdecl">atdecl</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Theory declarations. The list of declarations in a Theory may only contain Axioms.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TAxiom" class="def variant constructor anchored"><a href="#type-tdecl.TAxiom" class="anchor"></a><code><span>| </span><span><span class="constructor">TAxiom</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * string * <a href="../Util/index.html#type-axiom_kind">Util.axiom_kind</a> * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>New axiom that can be used in proofs.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TRewriting" class="def variant constructor anchored"><a href="#type-tdecl.TRewriting" class="anchor"></a><code><span>| </span><span><span class="constructor">TRewriting</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * string * <span><span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> <a href="#type-rwt_rule">rwt_rule</a></span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>New rewrite rule that can be used.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TGoal" class="def variant constructor anchored"><a href="#type-tdecl.TGoal" class="anchor"></a><code><span>| </span><span><span class="constructor">TGoal</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * <a href="../Ty/index.html#type-goal_sort">Ty.goal_sort</a> * string * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>New goal to prove.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TLogic" class="def variant constructor anchored"><a href="#type-tdecl.TLogic" class="anchor"></a><code><span>| </span><span><span class="constructor">TLogic</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * <span>string list</span> * <a href="#type-tlogic_type">tlogic_type</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function (or predicate) type declaration.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TPredicate_def" class="def variant constructor anchored"><a href="#type-tdecl.TPredicate_def" class="anchor"></a><code><span>| </span><span><span class="constructor">TPredicate_def</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * string * <span><span>(string * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span> * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Predicate definition. <code>TPredicate_def (loc, name, vars, body)</code> defines a predicate <code>fun vars =&gt; body</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TFunction_def" class="def variant constructor anchored"><a href="#type-tdecl.TFunction_def" class="anchor"></a><code><span>| </span><span><span class="constructor">TFunction_def</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * string * <span><span>(string * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span> * <a href="../Ty/index.html#type-t">Ty.t</a> * <span><span class="type-var">'a</span> <a href="#type-atform">atform</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Predicate definition. <code>TPredicate_def (loc, name, vars, ret, body)</code> defines a function <code>fun vars =&gt; body</code>, where body has type <code>ret</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TTypeDecl" class="def variant constructor anchored"><a href="#type-tdecl.TTypeDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">TTypeDecl</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * <a href="../Ty/index.html#type-t">Ty.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>New type declaration. <code>TTypeDecl (loc, vars, t, body)</code> declares a type <code>t</code>, with parameters <code>vars</code>, and with contents <code>body</code>. This new type may either be abstract, a record type, or an enumeration.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TPush" class="def variant constructor anchored"><a href="#type-tdecl.TPush" class="anchor"></a><code><span>| </span><span><span class="constructor">TPush</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>push (loc,n)</code> pushs n new assertions levels onto the assertion stack</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TPop" class="def variant constructor anchored"><a href="#type-tdecl.TPop" class="anchor"></a><code><span>| </span><span><span class="constructor">TPop</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p><code>pop (loc,n)</code> pops n assertions levels from the assertion stack</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TReset" class="def variant constructor anchored"><a href="#type-tdecl.TReset" class="anchor"></a><code><span>| </span><span><span class="constructor">TReset</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Resets all the context.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TExit" class="def variant constructor anchored"><a href="#type-tdecl.TExit" class="anchor"></a><code><span>| </span><span><span class="constructor">TExit</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Exits the solver.</p><span class="comment-delim">*)</span></div></li><li id="type-tdecl.TOptimize" class="def variant constructor anchored"><a href="#type-tdecl.TOptimize" class="anchor"></a><code><span>| </span><span><span class="constructor">TOptimize</span> <span class="keyword">of</span> <a href="../Loc/index.html#type-t">Loc.t</a> * <span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> * bool</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optimization declaration. <code>TOptimize (loc, obj, is_max)</code> declares an objective function <code>obj</code>. The flag <code>is_max</code> determines if we try to maximize of minimize <code>obj</code>.</p><span class="comment-delim">*)</span></div></li></ol></div></div><p>Typed declarations.</p><h6 id="printing"><a href="#printing" class="anchor"></a>Printing</h6><div class="odoc-spec"><div class="spec value anchored" id="val-print_term"><a href="#val-print_term" class="anchor"></a><code><span><span class="keyword">val</span> print_term : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-atterm">atterm</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print annoted typed terms. Ignore the annotations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_formula"><a href="#val-print_formula" class="anchor"></a><code><span><span class="keyword">val</span> print_formula : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-atform">atform</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print annoted typed formulas; Ignores the annotations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_binders"><a href="#val-print_binders" class="anchor"></a><code><span><span class="keyword">val</span> print_binders : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../Symbols/index.html#type-t">Symbols.t</a> * <a href="../Ty/index.html#type-t">Ty.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print a list of bound typed variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_triggers"><a href="#val-print_triggers" class="anchor"></a><code><span><span class="keyword">val</span> print_triggers : 
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><span><span class="type-var">'a</span> <a href="#type-atterm">atterm</a></span> list</span> * bool)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Print a list of triggers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_rwt"><a href="#val-print_rwt" class="anchor"></a><code><span><span class="keyword">val</span> print_rwt : 
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-rwt_rule">rwt_rule</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Print a rewrite rule</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_atdecl"><a href="#val-print_atdecl" class="anchor"></a><code><span><span class="keyword">val</span> print_atdecl : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">_</span> <a href="#type-atdecl">atdecl</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print an annoted term decl.</p></div></div></div></body></html>
