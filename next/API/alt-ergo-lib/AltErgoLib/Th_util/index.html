<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Th_util (alt-ergo-lib.AltErgoLib.Th_util)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../index.html">AltErgoLib</a> &#x00BB; Th_util</nav><header class="odoc-preamble"><h1>Module <code><span>AltErgoLib.Th_util</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-answer"><a href="#type-answer" class="anchor"></a><code><span><span class="keyword">type</span> answer</span><span> = <span><span>(<a href="../Explanation/index.html#type-t">Explanation.t</a> * <span><span class="xref-unresolved">AltErgoLib</span>.Expr.Set.t list</span>)</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-theory"><a href="#type-theory" class="anchor"></a><code><span><span class="keyword">type</span> theory</span><span> = </span></code><ol><li id="type-theory.Th_arith" class="def variant constructor anchored"><a href="#type-theory.Th_arith" class="anchor"></a><code><span>| </span><span><span class="constructor">Th_arith</span></span></code></li><li id="type-theory.Th_sum" class="def variant constructor anchored"><a href="#type-theory.Th_sum" class="anchor"></a><code><span>| </span><span><span class="constructor">Th_sum</span></span></code></li><li id="type-theory.Th_adt" class="def variant constructor anchored"><a href="#type-theory.Th_adt" class="anchor"></a><code><span>| </span><span><span class="constructor">Th_adt</span></span></code></li><li id="type-theory.Th_arrays" class="def variant constructor anchored"><a href="#type-theory.Th_arrays" class="anchor"></a><code><span>| </span><span><span class="constructor">Th_arrays</span></span></code></li><li id="type-theory.Th_bitv" class="def variant constructor anchored"><a href="#type-theory.Th_bitv" class="anchor"></a><code><span>| </span><span><span class="constructor">Th_bitv</span></span></code></li><li id="type-theory.Th_UF" class="def variant constructor anchored"><a href="#type-theory.Th_UF" class="anchor"></a><code><span>| </span><span><span class="constructor">Th_UF</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_theory"><a href="#val-pp_theory" class="anchor"></a><code><span><span class="keyword">val</span> pp_theory : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-theory">theory</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-show_theory"><a href="#val-show_theory" class="anchor"></a><code><span><span class="keyword">val</span> show_theory : <span><a href="#type-theory">theory</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lit_origin"><a href="#type-lit_origin" class="anchor"></a><code><span><span class="keyword">type</span> lit_origin</span><span> = </span></code><ol><li id="type-lit_origin.Subst" class="def variant constructor anchored"><a href="#type-lit_origin.Subst" class="anchor"></a><code><span>| </span><span><span class="constructor">Subst</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Only equalities can be <a href="#type-lit_origin.Subst"><code>Subst</code></a> literals, and they are oriented: the left-hand side is always an uninterpreted term or AC symbol application. Effectively, <a href="#type-lit_origin.Subst"><code>Subst</code></a> literals are the substitutions generated by calls to <code>X.solve</code> and propagated through the CC(X) and AC(X) algorithms.</p><p>In practice, a <a href="#type-lit_origin.Subst"><code>Subst</code></a> equality <code>r = rr</code> is generated when the corresponding substitution is performed by CC(X), i.e. when <code>rr</code> becomes the class representative for <code>r</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-lit_origin.CS" class="def variant constructor anchored"><a href="#type-lit_origin.CS" class="anchor"></a><code><span>| </span><span><span class="constructor">CS</span> <span class="keyword">of</span> <a href="#type-theory">theory</a> * <a href="../Numbers/Q/index.html#type-t">Numbers.Q.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Literals of <a href="#type-lit_origin.CS"><code>CS</code></a> origin come from the case splits performed by a specific theory. Usually, they are equalities of the shape <code>x = v</code> where <code>x</code> is an uninterpreted term and <code>v</code> a value; however, this is not necessarily the case (e.g. <a href="#type-lit_origin.CS"><code>CS</code></a> literals from the theory of arrays are often disequalities).</p><p>Depending on the theory, the shape of <a href="#type-lit_origin.CS"><code>CS</code></a> literals can be restricted. In particular, <a href="#type-lit_origin.CS"><code>CS</code></a> literals of the <a href="#type-theory.Th_UF"><code>Th_UF</code></a> theory: those come from model generation in the union-find, and are assignments, i.e. equalities <code>x = v</code> where <code>x</code> is uninterpreted and <code>v</code> is a value.</p><p>The rational argument estimates the size of the split -- usually, the number of possible values the theory could choose for this specific uninterpreted term.</p><span class="comment-delim">*)</span></div></li><li id="type-lit_origin.NCS" class="def variant constructor anchored"><a href="#type-lit_origin.NCS" class="anchor"></a><code><span>| </span><span><span class="constructor">NCS</span> <span class="keyword">of</span> <a href="#type-theory">theory</a> * <a href="../Numbers/Q/index.html#type-t">Numbers.Q.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Literals of <a href="#type-lit_origin.NCS"><code>NCS</code></a> origin are created from a literal of <a href="#type-lit_origin.CS"><code>CS</code></a> origin when the choice made in a case split turns out to be unsatisfiable. The literal is a negation of a <a href="#type-lit_origin.CS"><code>CS</code></a> literal that was built by the corresponding theory, with the restrictions that this implies.</p><span class="comment-delim">*)</span></div></li><li id="type-lit_origin.Other" class="def variant constructor anchored"><a href="#type-lit_origin.Other" class="anchor"></a><code><span>| </span><span><span class="constructor">Other</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Literals of <a href="#type-lit_origin.Other"><code>Other</code></a> are those that are not covered by any of the cases described above. In particular, user assertions, SAT decisions, SAT propagations and theory propagations all have the <a href="#type-lit_origin.Other"><code>Other</code></a> origin.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Indicates where asserted literals come from.</p><p>Note that literals are deduplicated before being propagated to the relations. <a href="#type-lit_origin.Subst"><code>Subst</code></a> literals are preserved, but other kinds of literals may be subsumed.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-case_split"><a href="#type-case_split" class="anchor"></a><code><span><span class="keyword">type</span> case_split</span><span> = <span><a href="../Shostak/Combine/index.html#type-r">Shostak.Combine.r</a> <a href="../Xliteral/index.html#type-view">Xliteral.view</a></span> * bool * <a href="#type-lit_origin">lit_origin</a></span></code></div><div class="spec-doc"><p>A case split is a triple <code>(a, is_cs, origin)</code>.</p><p>The literal <code>a</code> is simply the literal that is the source of the split, or its negation (depending on <code>origin</code>).</p><p>The <code>origin</code> should be either <code>CS</code> or <code>NCS</code>. Case splits returned by relations have an origin of <code>CS</code>, which is then flipped to <code>NCS</code> if a contradiction is found involving <code>a</code>.</p><p>The <code>is_cs</code> flag should *always* be <code>true</code>, unless the literal <code>a</code> is a *unit fact*, i.e. a fact that is true in all possible environments, not merely the current one. Note that it is acceptable for unit facts to be returned with <code>is_cs = true</code>; but if the <code>is_cs</code> flag is <code>false</code>, the solver *will* assume that the literal can't take part in any conflict. Returning <code>is_cs = false</code> if the literal is not an unit fact **is unsound**.</p><p>TL;DR: When in doubt, just set <code>is_cs</code> to <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-optimized_split"><a href="#type-optimized_split" class="anchor"></a><code><span><span class="keyword">type</span> optimized_split</span><span> = </span><span>{</span></code><ol><li id="type-optimized_split.value" class="def record field anchored"><a href="#type-optimized_split.value" class="anchor"></a><code><span>value : <a href="../Objective/Value/index.html#type-t">Objective.Value.t</a>;</span></code></li><li id="type-optimized_split.case_split" class="def record field anchored"><a href="#type-optimized_split.case_split" class="anchor"></a><code><span>case_split : <a href="#type-case_split">case_split</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The underlying case-split. Notice that the value propagate by this case-split doesn't always agree with the objective value <code>value</code>. Indeed, <code>value</code> isn't always a proper model value when the problem is unbounded or some objective functions involved strict inequalities.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-acts"><a href="#type-acts" class="anchor"></a><code><span><span class="keyword">type</span> <span>'literal acts</span></span><span> = </span><span>{</span></code><ol><li id="type-acts.acts_add_decision_lit" class="def record field anchored"><a href="#type-acts.acts_add_decision_lit" class="anchor"></a><code><span>acts_add_decision_lit : <span><span class="type-var">'literal</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Ask the SAT solver to decide on the given formula before it can answer <code>SAT</code>. The order of decisions among multiple calls of <code>acts_add_decision_lit</code> is unspecified.</p><p>Decisions added using <code>acts_add_decision_lit</code> are forgotten when backtracking.</p><span class="comment-delim">*)</span></div></li><li id="type-acts.acts_add_split" class="def record field anchored"><a href="#type-acts.acts_add_split" class="anchor"></a><code><span>acts_add_split : <span><span class="type-var">'literal</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let the SAT solver know about a case split. The SAT solver should decide on the provided formula before answering <code>Sat</code>, although it is not required to do so. The order of decisions among multiple calls of <code>acts_add_split</code> is unspecified, and the solver is allowed to drop some of them.</p><p>Splits added using <code>acts_add_split</code> are forgotten when backtracking.</p><span class="comment-delim">*)</span></div></li><li id="type-acts.acts_add_objective" class="def record field anchored"><a href="#type-acts.acts_add_objective" class="anchor"></a><code><span>acts_add_objective : <span><a href="../Objective/Function/index.html#type-t">Objective.Function.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Objective/Value/index.html#type-t">Objective.Value.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'literal</span> <span class="arrow">&#45;&gt;</span></span>
  unit;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Ask the SAT solver to optimistically select the appropriate value for the given objective function (encoded as a decision in the <code>'literal</code>). If the solver backtracks on that decision, the theory will have an opportunity to select another value in a context where the <code>'literal</code> is negated.</p><p>In case multiple objectives are added before the solver gets to make a decision, only the *last* objective is taken into consideration; you cannot assume that the objective has been optimized until the objective is sent back to the theory through <code>add_objective</code>.</p><p>Objectives added using <code>acts_add_objective</code> are forgotten when backtracking.</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The type of actions that a theory can take.</p><p>Inspired by mSAT's equivalent type <code>1</code>.</p><p><code>1</code> : https://github.com/Gbury/mSAT/blob/ \ 1496a48bc8b948e4d5a2bc20edaec33a6901c8fa/src/core/Solver_intf.ml#L104</p></div></div></div></body></html>
