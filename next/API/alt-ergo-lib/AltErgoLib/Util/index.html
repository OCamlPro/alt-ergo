<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Util (alt-ergo-lib.AltErgoLib.Util)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../index.html">AltErgoLib</a> &#x00BB; Util</nav><header class="odoc-preamble"><h1>Module <code><span>AltErgoLib.Util</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-Timeout"><a href="#exception-Timeout" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Timeout</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Step_limit_reached"><a href="#exception-Step_limit_reached" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Step_limit_reached</span> <span class="keyword">of</span> int</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unsolvable"><a href="#exception-Unsolvable" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unsolvable</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cmp"><a href="#exception-Cmp" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cmp</span> <span class="keyword">of</span> int</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Not_implemented"><a href="#exception-Not_implemented" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Not_implemented</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MI"><a href="#module-MI" class="anchor"></a><code><span><span class="keyword">module</span> MI</span><span> : <span class="xref-unresolved">Stdlib</span>.Map.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">key</span> = <span class="xref-unresolved">int</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-SI"><a href="#module-SI" class="anchor"></a><code><span><span class="keyword">module</span> SI</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="xref-unresolved">int</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MS"><a href="#module-MS" class="anchor"></a><code><span><span class="keyword">module</span> MS</span><span> : <span class="xref-unresolved">Stdlib</span>.Map.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">key</span> = <span class="xref-unresolved">string</span></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-SS"><a href="#module-SS" class="anchor"></a><code><span><span class="keyword">module</span> SS</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="xref-unresolved">string</span></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-case_split_policy"><a href="#type-case_split_policy" class="anchor"></a><code><span><span class="keyword">type</span> case_split_policy</span><span> = </span></code><ol><li id="type-case_split_policy.AfterTheoryAssume" class="def variant constructor anchored"><a href="#type-case_split_policy.AfterTheoryAssume" class="anchor"></a><code><span>| </span><span><span class="constructor">AfterTheoryAssume</span></span></code></li><li id="type-case_split_policy.BeforeMatching" class="def variant constructor anchored"><a href="#type-case_split_policy.BeforeMatching" class="anchor"></a><code><span>| </span><span><span class="constructor">BeforeMatching</span></span></code></li><li id="type-case_split_policy.AfterMatching" class="def variant constructor anchored"><a href="#type-case_split_policy.AfterMatching" class="anchor"></a><code><span>| </span><span><span class="constructor">AfterMatching</span></span></code></li></ol></div><div class="spec-doc"><p>Different values for -case-split-policy option: -after-theory-assume (default value): after assuming facts in theory by the SAT -before-matching: just before performing a matching round -after-matching: just after performing a matching round *</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inst_kind"><a href="#type-inst_kind" class="anchor"></a><code><span><span class="keyword">type</span> inst_kind</span><span> = </span></code><ol><li id="type-inst_kind.Normal" class="def variant constructor anchored"><a href="#type-inst_kind.Normal" class="anchor"></a><code><span>| </span><span><span class="constructor">Normal</span></span></code></li><li id="type-inst_kind.Forward" class="def variant constructor anchored"><a href="#type-inst_kind.Forward" class="anchor"></a><code><span>| </span><span><span class="constructor">Forward</span></span></code></li><li id="type-inst_kind.Backward" class="def variant constructor anchored"><a href="#type-inst_kind.Backward" class="anchor"></a><code><span>| </span><span><span class="constructor">Backward</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-sat_solver"><a href="#type-sat_solver" class="anchor"></a><code><span><span class="keyword">type</span> sat_solver</span><span> = </span></code><ol><li id="type-sat_solver.Tableaux" class="def variant constructor anchored"><a href="#type-sat_solver.Tableaux" class="anchor"></a><code><span>| </span><span><span class="constructor">Tableaux</span></span></code></li><li id="type-sat_solver.Tableaux_CDCL" class="def variant constructor anchored"><a href="#type-sat_solver.Tableaux_CDCL" class="anchor"></a><code><span>| </span><span><span class="constructor">Tableaux_CDCL</span></span></code></li><li id="type-sat_solver.CDCL" class="def variant constructor anchored"><a href="#type-sat_solver.CDCL" class="anchor"></a><code><span>| </span><span><span class="constructor">CDCL</span></span></code></li><li id="type-sat_solver.CDCL_Tableaux" class="def variant constructor anchored"><a href="#type-sat_solver.CDCL_Tableaux" class="anchor"></a><code><span>| </span><span><span class="constructor">CDCL_Tableaux</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_sat_solver"><a href="#val-pp_sat_solver" class="anchor"></a><code><span><span class="keyword">val</span> pp_sat_solver : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-sat_solver">sat_solver</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-theories_extensions"><a href="#type-theories_extensions" class="anchor"></a><code><span><span class="keyword">type</span> theories_extensions</span><span> = </span></code><ol><li id="type-theories_extensions.Sum" class="def variant constructor anchored"><a href="#type-theories_extensions.Sum" class="anchor"></a><code><span>| </span><span><span class="constructor">Sum</span></span></code></li><li id="type-theories_extensions.Adt" class="def variant constructor anchored"><a href="#type-theories_extensions.Adt" class="anchor"></a><code><span>| </span><span><span class="constructor">Adt</span></span></code></li><li id="type-theories_extensions.Arrays" class="def variant constructor anchored"><a href="#type-theories_extensions.Arrays" class="anchor"></a><code><span>| </span><span><span class="constructor">Arrays</span></span></code></li><li id="type-theories_extensions.Records" class="def variant constructor anchored"><a href="#type-theories_extensions.Records" class="anchor"></a><code><span>| </span><span><span class="constructor">Records</span></span></code></li><li id="type-theories_extensions.Bitv" class="def variant constructor anchored"><a href="#type-theories_extensions.Bitv" class="anchor"></a><code><span>| </span><span><span class="constructor">Bitv</span></span></code></li><li id="type-theories_extensions.LIA" class="def variant constructor anchored"><a href="#type-theories_extensions.LIA" class="anchor"></a><code><span>| </span><span><span class="constructor">LIA</span></span></code></li><li id="type-theories_extensions.LRA" class="def variant constructor anchored"><a href="#type-theories_extensions.LRA" class="anchor"></a><code><span>| </span><span><span class="constructor">LRA</span></span></code></li><li id="type-theories_extensions.NRA" class="def variant constructor anchored"><a href="#type-theories_extensions.NRA" class="anchor"></a><code><span>| </span><span><span class="constructor">NRA</span></span></code></li><li id="type-theories_extensions.NIA" class="def variant constructor anchored"><a href="#type-theories_extensions.NIA" class="anchor"></a><code><span>| </span><span><span class="constructor">NIA</span></span></code></li><li id="type-theories_extensions.FPA" class="def variant constructor anchored"><a href="#type-theories_extensions.FPA" class="anchor"></a><code><span>| </span><span><span class="constructor">FPA</span></span></code></li><li id="type-theories_extensions.RIA" class="def variant constructor anchored"><a href="#type-theories_extensions.RIA" class="anchor"></a><code><span>| </span><span><span class="constructor">RIA</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-axiom_kind"><a href="#type-axiom_kind" class="anchor"></a><code><span><span class="keyword">type</span> axiom_kind</span><span> = </span></code><ol><li id="type-axiom_kind.Default" class="def variant constructor anchored"><a href="#type-axiom_kind.Default" class="anchor"></a><code><span>| </span><span><span class="constructor">Default</span></span></code></li><li id="type-axiom_kind.Propagator" class="def variant constructor anchored"><a href="#type-axiom_kind.Propagator" class="anchor"></a><code><span>| </span><span><span class="constructor">Propagator</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mode"><a href="#type-mode" class="anchor"></a><code><span><span class="keyword">type</span> mode</span><span> = </span></code><ol><li id="type-mode.Start" class="def variant constructor anchored"><a href="#type-mode.Start" class="anchor"></a><code><span>| </span><span><span class="constructor">Start</span></span></code></li><li id="type-mode.Assert" class="def variant constructor anchored"><a href="#type-mode.Assert" class="anchor"></a><code><span>| </span><span><span class="constructor">Assert</span></span></code></li><li id="type-mode.Sat" class="def variant constructor anchored"><a href="#type-mode.Sat" class="anchor"></a><code><span>| </span><span><span class="constructor">Sat</span></span></code></li><li id="type-mode.Unsat" class="def variant constructor anchored"><a href="#type-mode.Unsat" class="anchor"></a><code><span>| </span><span><span class="constructor">Unsat</span></span></code></li></ol></div><div class="spec-doc"><p>The different modes alt-ergo can be in. https://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf#52</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_mode"><a href="#val-equal_mode" class="anchor"></a><code><span><span class="keyword">val</span> equal_mode : <span><a href="#type-mode">mode</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-mode">mode</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_mode"><a href="#val-pp_mode" class="anchor"></a><code><span><span class="keyword">val</span> pp_mode : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-mode">mode</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-th_ext_of_string"><a href="#val-th_ext_of_string" class="anchor"></a><code><span><span class="keyword">val</span> th_ext_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-theories_extensions">theories_extensions</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_th_ext"><a href="#val-string_of_th_ext" class="anchor"></a><code><span><span class="keyword">val</span> string_of_th_ext : <span><a href="#type-theories_extensions">theories_extensions</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_algebraic"><a href="#val-compare_algebraic" class="anchor"></a><code><span><span class="keyword">val</span> compare_algebraic : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<span class="type-var">'a</span> * <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>generic function for comparing algebraic data types. <code>compare_algebraic a b f</code></p><ul><li>Stdlib.compare a b is used if</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cmp_lists"><a href="#val-cmp_lists" class="anchor"></a><code><span><span class="keyword">val</span> cmp_lists : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-matching_env"><a href="#type-matching_env" class="anchor"></a><code><span><span class="keyword">type</span> matching_env</span><span> = </span><span>{</span></code><ol><li id="type-matching_env.nb_triggers" class="def record field anchored"><a href="#type-matching_env.nb_triggers" class="anchor"></a><code><span>nb_triggers : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Limit the number of trigger generated per axiom.</p><span class="comment-delim">*)</span></div></li><li id="type-matching_env.triggers_var" class="def record field anchored"><a href="#type-matching_env.triggers_var" class="anchor"></a><code><span>triggers_var : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If <code>true</code>, we allow trigger variables during the trigger generation.</p><span class="comment-delim">*)</span></div></li><li id="type-matching_env.no_ematching" class="def record field anchored"><a href="#type-matching_env.no_ematching" class="anchor"></a><code><span>no_ematching : bool;</span></code></li><li id="type-matching_env.greedy" class="def record field anchored"><a href="#type-matching_env.greedy" class="anchor"></a><code><span>greedy : bool;</span></code></li><li id="type-matching_env.use_cs" class="def record field anchored"><a href="#type-matching_env.use_cs" class="anchor"></a><code><span>use_cs : bool;</span></code></li><li id="type-matching_env.backward" class="def record field anchored"><a href="#type-matching_env.backward" class="anchor"></a><code><span>backward : <a href="#type-inst_kind">inst_kind</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-loop"><a href="#val-loop" class="anchor"></a><code><span><span class="keyword">val</span> loop : <span><span class="label">f</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">max</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">elt</span>:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">init</span>:<span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p>Loops from 0 to <code>max</code> and returns <code>(f max elt ... (f 1 elt (f 0 elt init)))...)</code>. Returns <code>init</code> if <code>max</code> &lt; 0</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_list"><a href="#val-print_list" class="anchor"></a><code><span><span class="keyword">val</span> print_list : 
  <span><span class="label">sep</span>:string <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">pp</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_list_pp"><a href="#val-print_list_pp" class="anchor"></a><code><span><span class="keyword">val</span> print_list_pp : 
  <span><span class="label">sep</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">pp</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-internal_error"><a href="#val-internal_error" class="anchor"></a><code><span><span class="keyword">val</span> internal_error : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="xref-unresolved">Stdlib</span>.Format.formatter, unit, <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Stdlib</span>.format4</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div></div></body></html>
