<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Int (alt-ergo-lib.AltErgoLib.Intervals.Int)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../../odoc.support/katex.min.css"/><script src="../../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../../index.html">AltErgoLib</a> &#x00BB; <a href="../index.html">Intervals</a> &#x00BB; Int</nav><header class="odoc-preamble"><h1>Module <code><span>Intervals.Int</span></code></h1><p>Union-of-intervals over integers.</p></header><nav class="odoc-toc"><ul><li><a href="#bit-vector-helpers">Bit-vector helpers</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../Intervals_intf/module-type-EuclideanRing/index.html">Intervals_intf.EuclideanRing</a>
  <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Intervals_intf/module-type-EuclideanRing/index.html#type-explanation">explanation</a> := <a href="../../Explanation/index.html#type-t">Explanation.t</a></span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Intervals_intf/module-type-EuclideanRing/index.html#type-value">value</a> := <span class="xref-unresolved">Z</span>.t</span>
   <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="../../Intervals_intf/module-type-EuclideanRing/index.html#type-union">union</a></span> = <span><span class="type-var">'a</span> <a href="../index.html#type-union">union</a></span></span></span></code></summary><p>Given an explanation <code class="odoc-katex-math">e</code> (see <a href="../../Intervals_intf/module-type-Explanations/index.html"><code>Intervals_intf.Explanations</code></a>), we say that an interval <code class="odoc-katex-math">I</code> is forbidden for a variable <code class="odoc-katex-math">x</code> by <code class="odoc-katex-math">e</code> if <code class="odoc-katex-math">M(x)</code> is never in <code class="odoc-katex-math">I</code> when <code class="odoc-katex-math">M</code> is a model such that <code class="odoc-katex-math">M(e)</code> is <code>true</code>, i.e. if the following implication holds:</p><div><pre class="odoc-katex-math display">\forall M, M(e) \Rightarrow M(x) \not\in I</pre></div><p>Given a current context <code class="odoc-katex-math">C</code> (a set of explanations) and an implicit variable <code class="odoc-katex-math">x</code>, we say that an interval <code class="odoc-katex-math">I</code> is <em>forbidden</em> if it is forbidden by an union of explanations in <code class="odoc-katex-math">C</code>, and that it is <em>allowed</em> otherwise.</p><p>It is always sound to weaken a forbidden interval interval: if <code class="odoc-katex-math">M(e_1)
      \Rightarrow M(e_2)</code> and <code class="odoc-katex-math">I</code> is forbidden by <code>e_2</code>, it is also forbidden by <code>e_1</code>.</p><p>(Note that in terms of explanations, this means adding more terms in the explanation, since <code>Explanation.empty</code> is true in all contexts and since <code>Explanation.union e1 e2</code> evaluates to <code class="odoc-katex-math">M(e_1) \wedge M(e_2)</code>.)</p><p>The <code>union</code> type below internally keeps track of both allowed and forbidden intervals, where each forbidden interval is annotated by a specific explanation (true in the current context) that forbids it, but the functions in this module provide abstractions to deal with the unions without having to worry about explanations (and forbidden intervals) directly.</p><p>In order to avoid having to worry about variables while reasoning about intervals, we define a contextual evaluation function for unions (and set of intervals); the evaluation of an allowed interval <code class="odoc-katex-math">I</code> is always <code class="odoc-katex-math">I</code> in all contexts, and the evaluation of a forbidden interval <code class="odoc-katex-math">I</code> is <code class="odoc-katex-math">I</code> in contexts where the associated explanation <b>does not hold</b>, and the empty set otherwise (in particular, it is the empty set in the current context).</p><p>Note that the evaluation of a forbidden interval is a subset of the interval in any context.</p><div class="odoc-spec"><div class="spec type anchored" id="type-bnd"><a href="#type-bnd" class="anchor"></a><code><span><span class="keyword">type</span> bnd</span></code></div><div class="spec-doc"><p>The type of bounds.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-union"><a href="#type-union" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a union</span></span><span> = <span><span class="type-var">'a</span> <a href="../index.html#type-union">union</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="#type-bnd">bnd</a> <a href="#type-union">union</a></span></span></code></div><div class="spec-doc"><p>The type of unions.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Interval"><a href="#module-Interval" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Interval/index.html">Interval</a></span><span> : 
  <a href="../../Intervals_intf/module-type-Interval/index.html">Intervals_intf.Interval</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../Intervals_intf/module-type-Interval/index.html#type-value">value</a> = <span class="xref-unresolved">Z</span>.t</span> <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="../../Intervals_intf/module-type-Interval/index.html#type-bnd">bnd</a> = <a href="#type-bnd">bnd</a></span></span></code></div><div class="spec-doc"><p>Intervals over the <code>value</code> type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="#type-t">t</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>Pretty-printer for unions.</p></div></div><h2 id="creation"><a href="#creation" class="anchor"></a>Creation</h2><p>The following functions are used to create unions.</p><div class="odoc-spec"><div class="spec value anchored" id="val-of_interval"><a href="#val-of_interval" class="anchor"></a><code><span><span class="keyword">val</span> of_interval : <span><span class="optlabel">?ex</span>:<a href="../../Explanation/index.html#type-t">Explanation.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Build an union from an interval.</p><p><code>of_interval ?ex:None i</code> evaluates to <code>i</code> in all contexts.</p><p><code>of_interval ~ex i</code> evaluates to <code>i</code> in contexts where <code>ex</code> holds (including the current context) and to the full set otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_bounds"><a href="#val-of_bounds" class="anchor"></a><code><span><span class="keyword">val</span> of_bounds : 
  <span><span class="optlabel">?ex</span>:<a href="../../Explanation/index.html#type-t">Explanation.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Z</span>.t <a href="../../Intervals_intf/index.html#type-bound">Intervals_intf.bound</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="xref-unresolved">Z</span>.t <a href="../../Intervals_intf/index.html#type-bound">Intervals_intf.bound</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_bounds ?ex lb ub</code> is a shortcut for <code>of_interval ?ex @@ Interval.of_bounds lb ub</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_complement"><a href="#val-of_complement" class="anchor"></a><code><span><span class="keyword">val</span> of_complement : 
  <span><span class="optlabel">?ex</span>:<a href="../../Explanation/index.html#type-t">Explanation.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <a href="../../Explanation/index.html#type-t">Explanation.t</a>)</span> <a href="../../Intervals_intf/index.html#type-kind">Intervals_intf.kind</a></span></span></code></div><div class="spec-doc"><p>Build an union from the complement of an interval.</p><p>The explanation, if provided, justifies that the value is <b>not</b> in the interval; the resulting union evaluates to the complement of the interval in any model where the explanation holds, and to the full set otherwise.</p><p>If the provided interval covers the full domain, the resulting union is empty and an <code>Empty</code> kind is returned; otherwise, the resulting union is <code>NonEmpty</code>.</p></div></div><h2 id="inspection"><a href="#inspection" class="anchor"></a>Inspection</h2><p>The following functions are used to inspect the global bounds of an union of intervals.</p><div class="odoc-spec"><div class="spec value anchored" id="val-lower_bound"><a href="#val-lower_bound" class="anchor"></a><code><span><span class="keyword">val</span> lower_bound : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <a href="../../Intervals_intf/index.html#type-bound">Intervals_intf.bound</a></span> * <a href="../../Explanation/index.html#type-t">Explanation.t</a></span></code></div><div class="spec-doc"><p><code>lower_bound u</code> returns a pair <code>lb, ex</code> of a global lower bound and an explanation that justifies that this lower bound is valid.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-upper_bound"><a href="#val-upper_bound" class="anchor"></a><code><span><span class="keyword">val</span> upper_bound : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Z</span>.t <a href="../../Intervals_intf/index.html#type-bound">Intervals_intf.bound</a></span> * <a href="../../Explanation/index.html#type-t">Explanation.t</a></span></code></div><div class="spec-doc"><p><code>upper_bound u</code> returns a pair <code>lb, ex</code> of a global upper bound and an explanation that justifies that this upper bound is valid.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-value_opt"><a href="#val-value_opt" class="anchor"></a><code><span><span class="keyword">val</span> value_opt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="xref-unresolved">Z</span>.t * <a href="../../Explanation/index.html#type-t">Explanation.t</a>)</span> option</span></span></code></div><div class="spec-doc"><p>If <code>u</code> is a singleton <b>in the current context</b>, <code>value_opt u</code> returns a pair <code>(v, ex)</code> where <code>v</code> is the value of <code>u</code> in the current context and <code>ex</code> justifies <code>v</code> being both a lower and upper bound.</p><p>This is more efficient than checking if the values returned by <code>lower_bound</code> and <code>upper_bound</code> are equal.</p></div></div><h2 id="iteration"><a href="#iteration" class="anchor"></a>Iteration</h2><p>The following functions are used to iterate over the maximal disjoint intervals composing the union <b>in the current context</b>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>Convert an union of interval to a sequence of maximal disjoint and non-adjacent intervals.</p><p><b>Warning</b>: The sequence of intervals is only valid in the current context.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f u</code> calls <code>f</code> on each of the maximal disjoint and non-adjacent intervals that make up the union <code>u</code> <b>in the current context</b>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fold f acc u</code> folds <code>f</code> over each of the maximal disjoint and non-adjacent intervals that make up the union <code>u</code> <b>in the current context</b>.</p></div></div><h2 id="comparison"><a href="#comparison" class="anchor"></a>Comparison</h2><p>The following functions are used to compare intervals <b>in the current context</b>.</p><div class="odoc-spec"><div class="spec value anchored" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span><span class="keyword">val</span> subset : <span><span class="optlabel">?strict</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>subset ?strict u1 u2</code> returns <code>true</code> if <code>u1</code> is a subset of <code>u2</code> <b>in the current context</b>. <code>subset</code> ignores all explanations.</p><p>If set, the <code>strict</code> flag (<code>false</code> by default) checks for strict inclusion.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal u1 u2</code> returns <code>true</code> if <code>u1</code> is equal to <code>u2</code> <b>in the current context</b>. <code>equal</code> ignores all explanations.</p></div></div><h2 id="set-manipulation"><a href="#set-manipulation" class="anchor"></a>Set manipulation</h2><div class="odoc-spec"><div class="spec value anchored" id="val-add_explanation"><a href="#val-add_explanation" class="anchor"></a><code><span><span class="keyword">val</span> add_explanation : <span><span class="label">ex</span>:<a href="../../Explanation/index.html#type-t">Explanation.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_explanation ~ex u</code> adds the explanation <code>ex</code> to the union <code>u</code>.</p><p>More precisely: <code>add_explanation ~ex u</code> is equivalent to <code>u</code> in models where <code>ex</code> holds, and is <code>Interval.full</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span><span class="keyword">val</span> intersect : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, <a href="../../Explanation/index.html#type-t">Explanation.t</a>)</span> <a href="../../Intervals_intf/index.html#type-kind">Intervals_intf.kind</a></span></span></code></div><div class="spec-doc"><p><code>intersect u1 u2</code> computes the intersection of <code>u1</code> and <code>u2</code>.</p><p>The resulting intersection is valid in all models.</p></div></div><h2 id="image-by-monotone-functions"><a href="#image-by-monotone-functions" class="anchor"></a>Image by monotone functions</h2><p>The following functions can compute the image of an union by monotone function on bounds.</p><div class="odoc-spec"><div class="spec value anchored" id="val-map_strict_inc"><a href="#val-map_strict_inc" class="anchor"></a><code><span><span class="keyword">val</span> map_strict_inc : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>map_strict_inc f u</code> computes the image of <code>u</code> by the <b>strictly increasing</b> function <code>f</code>.</p><p>This function is very efficient and should be used when possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_strict_dec"><a href="#val-map_strict_dec" class="anchor"></a><code><span><span class="keyword">val</span> map_strict_dec : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>map_strict_dec f u</code> computes the image of <code>u</code> by the <b>strictly decreasing</b> function <code>f</code>.</p><p>This function is very efficient and should be used when possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partial_map_inc"><a href="#val-partial_map_inc" class="anchor"></a><code><span><span class="keyword">val</span> partial_map_inc : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <a href="../../Explanation/index.html#type-t">Explanation.t</a>)</span> <a href="../../Intervals_intf/index.html#type-kind">Intervals_intf.kind</a></span></span></code></div><div class="spec-doc"><p><code>partial_map_inc f_lb f_ub u</code> computes the image of <code>u</code> by a partial (weakly) increasing function <code>f</code>.</p><p><code>f</code> is represented by the pair <code>(f_lb, f_ub)</code> of functions that are such that for any <code>x</code>, <code>f_lb x = f x = f_ub x</code> if <code>x</code> is in the domain of <code>f</code>, and <code>f_ub x &lt; f_lb x</code> otherwise.</p><p><b>Warning</b>: The functions <code>f_lb</code> and <code>f_ub</code> must themselve be (weakly) increasing. Moreover, the inequality <code>f_ub x &lt;= f_lb x</code> must hold everywhere; if <code>f_lb</code> and <code>f_ub</code> are imprecise approximations of <code>f</code>, use <a href="#val-approx_map_inc_to_set"><code>approx_map_inc_to_set</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partial_map_dec"><a href="#val-partial_map_dec" class="anchor"></a><code><span><span class="keyword">val</span> partial_map_dec : 
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <a href="../../Explanation/index.html#type-t">Explanation.t</a>)</span> <a href="../../Intervals_intf/index.html#type-kind">Intervals_intf.kind</a></span></span></code></div><div class="spec-doc"><p><code>partial_map_dec f_lb f_ub u</code> computes the image of <code>u</code> by a partial (weakly) decreasing function <code>f</code>.</p><p><code>f</code> is represented by the pair <code>(f_lb, f_ub)</code> of functions that are such that for any <code>x</code>, <code>f_lb x = f x = f_ub x</code> if <code>x</code> is in the domain of <code>f</code>, and <code>f_ub x &lt; f_lb x</code> otherwise.</p><p><b>Warning</b>: The functions <code>f_lb</code> and <code>f_ub</code> must themselve be (weakly) decreasing. Moreover, the inequality <code>f_ub x &lt;= f_lb x</code> must hold everywhere; if <code>f_lb</code> and <code>f_ub</code> are imprecise approximations of <code>f</code>, use <a href="#val-approx_map_dec_to_set"><code>approx_map_dec_to_set</code></a> instead.</p></div></div><h2 id="image-by-arbitrary-functions"><a href="#image-by-arbitrary-functions" class="anchor"></a>Image by arbitrary functions</h2><p>When computing the image of an union by non-monotone functions and multi-variate functions, work needs to be done to convert intermediate results into a normalized form of disjoint intervals (because applying the function to initially disjoint intervals can create arbitrary unions).</p><p>In such cases, the following family of <code>to_set</code> functions should be used. The use the <code>set</code> type to represent intermediate results, which can be converted back to an union using the <code>of_set</code> family of functions as needed.</p><div class="odoc-spec"><div class="spec type anchored" id="type-set"><a href="#type-set" class="anchor"></a><code><span><span class="keyword">type</span> set</span></code></div><div class="spec-doc"><p>The <code>set</code> type represents a (possibly empty) set of intervals.</p><p>Unlike an <code>union</code>, it is not normalized: it is an intermediate type not intended to be manipulated directly, except in the process of building an union. Use the <code>of_set</code> family of functions to convert it to an union as needed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty_set"><a href="#val-empty_set" class="anchor"></a><code><span><span class="keyword">val</span> empty_set : <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>empty_set</code> represents an empty set of intervals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interval_set"><a href="#val-interval_set" class="anchor"></a><code><span><span class="keyword">val</span> interval_set : <span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>interval_set i</code> represents the interval <code>i</code> as a <code>set</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union_set"><a href="#val-union_set" class="anchor"></a><code><span><span class="keyword">val</span> union_set : <span><a href="#type-set">set</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-set">set</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>union_set f1 f2</code> computes the union of the sets of intervals represented by <code>f1</code> and <code>f2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_set"><a href="#val-map_set" class="anchor"></a><code><span><span class="keyword">val</span> map_set : 
  <span><span>(<span><span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-set">set</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>map_set f s</code> applies the function <code>f</code> to all the intervals in <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_set_checked"><a href="#val-of_set_checked" class="anchor"></a><code><span><span class="keyword">val</span> of_set_checked : <span><a href="#type-set">set</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-t">t</a>, <a href="../../Explanation/index.html#type-t">Explanation.t</a>)</span> <a href="../../Intervals_intf/index.html#type-kind">Intervals_intf.kind</a></span></span></code></div><div class="spec-doc"><p>Converts a <code>set</code> to a nonempty union. Returns <code>Empty ex</code> if the set is currently empty, and <code>NonEmpty u</code> otherwise.</p><p>If a <code>NonEmpty</code> value is returned, the resulting union is guaranteed to be nonempty in the current context.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_set_nonempty"><a href="#val-of_set_nonempty" class="anchor"></a><code><span><span class="keyword">val</span> of_set_nonempty : <span><a href="#type-set">set</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Converts a <code>set</code> to an union, assuming that it is nonempty in the current context.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the <code>set</code> represents an union that is empty in the current context.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_to_set"><a href="#val-map_to_set" class="anchor"></a><code><span><span class="keyword">val</span> map_to_set : <span><span>(<span><span><span class="type-var">'a</span> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>map_to_set f u</code> computes the image of <code>u</code> by <code>f</code>.</p><p>Conceptually, this computes the union of <code>f x</code> for each <code>x</code> in <code>u</code>, although this is not possible to compute when <code>u</code> might not be finite. Instead, we represent <code>f</code> by a function from intervals to sets that must be isotone (i.e. monotone with respect to inclusion):</p><div><pre class="odoc-katex-math display">I_1 \subseteq I_2 \Rightarrow f(I_1) \subseteq f(I_2)</pre></div><p>There are no restrictions on <code>f</code> (except that it be isotone), which means that <code>map_to_set</code> needs to call <code>f</code> on currently allowed intervals, but also on some intervals that are currently impossible but would be possible in other contexts (depending on explanations).</p><p>When possible, prefer using a more specialized variant of <code>map_to_set</code> that use properties of the function <code>f</code> to avoid certain calls to <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_mon_to_set"><a href="#val-map_mon_to_set" class="anchor"></a><code><span><span class="keyword">val</span> map_mon_to_set : <span><span>(<span><span><span class="type-var">'a</span> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>map_mon_to_set</code> is a variant of <code>map_to_set</code> when the function <code>f</code> is monotone.</p><p>More precisely, we require that for any pair of intervals <code>(i1, i2)</code> the interval hull of <code>f i1</code> and <code>f i2</code> is included in the image of the interval hull of <code>i1</code> and <code>i2</code> by <code>f</code>.</p><p>It is often more convenient to use <code>approx_map_inc_to_set</code> or <code>approx_map_dec_to_set</code> instead, to lift a function on values to a function on unions without going through intervals.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-approx_map_inc_to_set"><a href="#val-approx_map_inc_to_set" class="anchor"></a><code><span><span class="keyword">val</span> approx_map_inc_to_set : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>approx_map_inc_to_set f_lb f_ub u</code> is a variant of <code>map_to_set</code> that is appropriate for (weakly) increasing functions.</p><p>The (weakly) increasing function <code>f</code> is represented by a pair <code>(f_lb, f_ub)</code> of functions such that for all <code>x</code> in the domain of <code>f</code>, <code>f_lb x &lt;= f x &lt;= f_ub x</code> (and <code>f_ub x &lt; f_lb x</code> otherwise).</p><p>Note that, unlike <code>partial_map_inc</code>, this function can be used with imprecise approximations: we allow <code>f_lb x &lt; f x &lt; f_ub x</code> (this is useful for radicals).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-approx_map_dec_to_set"><a href="#val-approx_map_dec_to_set" class="anchor"></a><code><span><span class="keyword">val</span> approx_map_dec_to_set : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>approx_map_inc_to_set f_lb f_ub u</code> is a variant of <code>map_to_set</code> that is appropriate for (weakly) decreasing functions.</p><p>The (weakly) decreasing function <code>f</code> is represented by a pair <code>(f_lb, f_ub)</code> of functions such that for all <code>x</code> in the domain of <code>f</code>, <code>f_lb x &lt;= f x &lt;= f_ub x</code> (and <code>f_ub x &lt; f_lb x</code> otherwise).</p><p>Note that, unlike <code>partial_map_dec</code>, this function can be used with imprecise approximations: we allow <code>f_lb x &lt; f x &lt; f_ub x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_inc_to_set"><a href="#val-map_inc_to_set" class="anchor"></a><code><span><span class="keyword">val</span> map_inc_to_set : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>map_inc_to_set f u</code> is a variant of <code>approx_map_inc_to_set</code> when the underlying function is total and precisely known.</p><p>See also <a href="#val-map_strict_inc"><code>map_strict_inc</code></a>.</p><p>Note that strict monotony is <b>not</b> required for <code>map_inc_to_set</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_dec_to_set"><a href="#val-map_dec_to_set" class="anchor"></a><code><span><span class="keyword">val</span> map_dec_to_set : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-bnd">bnd</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-union">union</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>map_dec_to_set f u</code> is a variant of <code>approx_map_dec_to_set</code> when the underlying function is total and precisely known.</p><p>See also <a href="#val-map_strict_dec"><code>map_strict_dec</code></a>.</p><p>Note that strict monotony is <b>not</b> required for <code>map_dec_to_set</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-trisection_map_to_set"><a href="#val-trisection_map_to_set" class="anchor"></a><code><span><span class="keyword">val</span> trisection_map_to_set : 
  <span><a href="#type-bnd">bnd</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-set">set</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-set">set</a></span></code></div><div class="spec-doc"><p><code>trisection_map_to_set v u f_lt f_eq f_gt</code> constructs an union of intervals by combining the image of <code>f_lt</code> on the fragment of <code>u</code> that only contains values strictly less than <code>v</code>, the image of <code>f_gt</code> on the fragment of <code>u</code> that only contains values strictly greater than <code>v</code>, and the image of <code>f_eq</code> if <code>v</code> is contained in <code>u</code>.</p><p>It is helpful to build piecewise monotone functions such as multiplication, where trisection around <code>0</code> can be used.</p></div></div><h2 id="ring-interface"><a href="#ring-interface" class="anchor"></a>Ring interface</h2><div class="odoc-spec"><div class="spec value anchored" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span><span class="keyword">val</span> neg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>neg u</code> evaluates to <code class="odoc-katex-math">\{ -x \mid x \in S \}</code> when <code>u</code> evaluates to <code class="odoc-katex-math">S</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add u1 u2</code> evaluates to <code class="odoc-katex-math">\{ x + y \mid x \in S_1, y \in S_2 \}</code> when <code>u1</code> evaluates to <code class="odoc-katex-math">S_1</code> and <code>u2</code> evaluates to <code class="odoc-katex-math">S_2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sub u1 u2</code> evaluates to <code class="odoc-katex-math">\{ x - y \mid x \in S_1, y \in S_2 \}</code> when <code>u1</code> evaluates to <code class="odoc-katex-math">S_1</code> and <code>u2</code> evaluates to <code class="odoc-katex-math">S_2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><span class="xref-unresolved">Z</span>.t <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>scale v u</code> evaluates to <code class="odoc-katex-math">\{ v \times x \mid x \in S \}</code> when <code>u</code> evaluates to <code class="odoc-katex-math">S</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>v</code> is zero.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mul u1 u2</code> evaluates to <code class="odoc-katex-math">\{ x \times y \mid x \in S_1, y \in S_2 \}</code> when <code>u1</code> evaluates to <code class="odoc-katex-math">S_1</code> and <code>u2</code> evaluates to <code class="odoc-katex-math">S_2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span><span class="keyword">val</span> pow : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pow n u</code> evaluates to <code class="odoc-katex-math">\{ x^n \mid x \in S \}</code> when <code>u</code> evaluates to <code class="odoc-katex-math">S</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if <code>n</code> is nonpositive.</p></li></ul></div></div><h2 id="euclidean-division"><a href="#euclidean-division" class="anchor"></a>Euclidean division</h2><div class="odoc-spec"><div class="spec value anchored" id="val-ediv"><a href="#val-ediv" class="anchor"></a><code><span><span class="keyword">val</span> ediv : <span><span class="optlabel">?div0</span>:<span><a href="#type-bnd">bnd</a> <a href="../../Intervals_intf/index.html#type-interval">Intervals_intf.interval</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ediv u1 u2</code> computes the image of euclidean division of a value in <code>u1</code> by a value in <code>u2</code>.</p><p><code>div0</code> (defaults to the full interval) is used as the image of division by <code>zero</code>.</p></div></div></details></div><h3 id="bit-vector-helpers"><a href="#bit-vector-helpers" class="anchor"></a>Bit-vector helpers</h3><p>These functions are intended for the BV theory. They can only be used with integer intervals. Some of these functions return intervals &quot;of width <code>n</code>&quot;, where <code>n</code> is computed from the parameters of the function. This means that the returned interval is contained in the range <code>[0, n)] ([0] inclusive, [n] exclusive). </code></p><div class="odoc-spec"><div class="spec value anchored" id="val-lognot"><a href="#val-lognot" class="anchor"></a><code><span><span class="keyword">val</span> lognot : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Bitwise logical negation. <code>lognot u</code> always returns <code>-u - 1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract"><a href="#val-extract" class="anchor"></a><code><span><span class="keyword">val</span> extract : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">ofs</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extract s i j</code> returns the bits of <code>s</code> from position <code>i</code> to <code>j</code>, inclusive.</p><p>Represents the function <code>fun x -&gt; floor(x / 2^i) % 2^(j - i + 1)</code>.</p><p>Requires <code>0 &lt;= i &lt;= j</code> and returns an interval of width <code>j - i + 1</code>.</p><p><b>Note</b>: The interval <code>s</code> must be an integer interval, but is allowed to be unbounded (in which case <code>extract s i j</code> returns the full interval <code>[0, 2^(j - i + 1) - 1]</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bvudiv"><a href="#val-bvudiv" class="anchor"></a><code><span><span class="keyword">val</span> bvudiv : <span><span class="label">size</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>bvudiv sz s t</code> computes an overapproximation of integer division for bit-vectors of width <code>sz</code> as defined in the FixedSizeBitVectors SMT-LIB theory, i.e. where <code>bvudiv n 0</code> is <code>2^sz - 1</code>.</p><p><code>s</code> and <code>t</code> must be within the <code>0, 2^sz - 1</code> range.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bvurem"><a href="#val-bvurem" class="anchor"></a><code><span><span class="keyword">val</span> bvurem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>bvurem sz s t</code> computes an overapproximation of integer remainder for bit-vectors of width <code>sz</code> as defined in the FixedSizeBitVectors SMT-LIB theory, i.e. where <code>bvurem n 0</code> is <code>n</code>.</p><p><code>s</code> and <code>t</code> must be within the <code>0, 2^sz - 1</code> range.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bvshl"><a href="#val-bvshl" class="anchor"></a><code><span><span class="keyword">val</span> bvshl : <span><span class="label">size</span>:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>shl sz s t</code> computes an overapproximation of the left shift <code>s lsl t</code>, truncating the result to <code>sz</code> bits.</p><p><code>s</code> and <code>t</code> must only contain non-negative integers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lshr"><a href="#val-lshr" class="anchor"></a><code><span><span class="keyword">val</span> lshr : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lshr s t</code> computes an approximation of the logical right shift <code>s lsr t</code>.</p><p>Note that the result of logical right shift is independent of bit width.</p><p><code>s</code> and <code>t</code> must only contain non-negative integers.</p></div></div></div></body></html>
