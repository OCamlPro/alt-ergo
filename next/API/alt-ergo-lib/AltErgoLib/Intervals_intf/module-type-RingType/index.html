<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>RingType (alt-ergo-lib.AltErgoLib.Intervals_intf.RingType)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><link rel="stylesheet" href="../../../../odoc.support/katex.min.css"/><script src="../../../../odoc.support/katex.min.js"></script><script>
//<![CDATA[

          document.addEventListener("DOMContentLoaded", function () {
            var elements = Array.from(document.getElementsByClassName("odoc-katex-math"));
            for (var i = 0; i < elements.length; i++) {
              var el = elements[i];
              var content = el.textContent;
              var new_el = document.createElement("span");
              new_el.setAttribute("class", "odoc-katex-math-rendered");
              var display = el.classList.contains("display");
              katex.render(content, new_el, { throwOnError: false, displayMode: display });
              el.replaceWith(new_el);
            }
          });
        
//]]>
</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../../index.html">AltErgoLib</a> &#x00BB; <a href="../index.html">Intervals_intf</a> &#x00BB; RingType</nav><header class="odoc-preamble"><h1>Module type <code><span>Intervals_intf.RingType</span></code></h1><p>An ordered ring is an ordered type with addition and multiplication that follows ring laws.</p></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../module-type-OrderedType/index.html">OrderedType</a></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-finite"><a href="#type-finite" class="anchor"></a><code><span><span class="keyword">type</span> finite</span></code></div><div class="spec-doc"><p>The type of finite values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_finite"><a href="#val-pp_finite" class="anchor"></a><code><span><span class="keyword">val</span> pp_finite : <span><a href="#type-finite">finite</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>Pretty-printer for finite values.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of extended values used to represent interval bounds.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="#type-t">t</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p>Pretty-printer for extended values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality on extended values. Must be compatible with <code>compare</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The comparison function on extended values is an extension of the regular order on finite values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-view"><a href="#val-view" class="anchor"></a><code><span><span class="keyword">val</span> view : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-finite">finite</a> <a href="../index.html#type-bound">bound</a></span></span></code></div><div class="spec-doc"><p><code>view t</code> converts the internal representation to a <code>bound</code> for examination.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-minfty"><a href="#val-minfty" class="anchor"></a><code><span><span class="keyword">val</span> minfty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>minfty</code> is an extended value <code class="odoc-katex-math">-\infty</code> such that for any extended value <code class="odoc-katex-math">x</code>, <code class="odoc-katex-math">-\infty \le x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finite"><a href="#val-finite" class="anchor"></a><code><span><span class="keyword">val</span> finite : <span><a href="#type-finite">finite</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Finite values are included in <code>t</code>. We will identify a finite value in <code>finite</code> and its representation in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pinfty"><a href="#val-pinfty" class="anchor"></a><code><span><span class="keyword">val</span> pinfty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pinfty</code> is an extended value <code class="odoc-katex-math">+\infty</code> such that for any extended value <code class="odoc-katex-math">x</code>, <code class="odoc-katex-math">x \le +\infty</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-value_opt"><a href="#val-value_opt" class="anchor"></a><code><span><span class="keyword">val</span> value_opt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-finite">finite</a> option</span></span></code></div><div class="spec-doc"><p><code>value_opt</code> is the partial inverse of <code>finite</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-succ"><a href="#val-succ" class="anchor"></a><code><span><span class="keyword">val</span> succ : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Each element of the ordered type <code>t</code> has a successor. The successor of an element is always greater than the element itself:</p><div><pre class="odoc-katex-math display">        \forall x, x \le \mathrm{succ}(x)
      </pre></div><p>We say that <code class="odoc-katex-math">x</code> is a <em>finite upper bound</em> if it is <em>strictly</em> smaller than its successor, i.e. if <code class="odoc-katex-math">x &lt; \mathrm{succ}(x)</code>, and we require that all <b>finite</b> values are finite upper bounds (however there may be finite upper bounds that are not finite values).</p><p><code>succ</code> must be the inverse of <code>pred</code> below.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pred"><a href="#val-pred" class="anchor"></a><code><span><span class="keyword">val</span> pred : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Each element of the ordered type <code>t</code> has a predecessor. The predecessor of an element is always smaller than the element itself:</p><div><pre class="odoc-katex-math display">        \forall x, \mathrm{pred}(x) \le x
      </pre></div><p>We say that <code class="odoc-katex-math">x</code> is a <em>finite lower bound</em> if it is <em>strictly</em> greater than its predecessor, i.e. if <code class="odoc-katex-math">\mathrm{pred}(x) &lt; x</code>, and we require that all <b>finite</b> values are finite lower bounds (however there may be finite lower bounds that are not finite values).</p><p><code>pred</code> must be the inverse of <code>succ</code> above.</p></div></div></details></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add</code> will only be called with values that are compatible with its monotonicity: its argument can never be two bounds of different kinds (upper or lower).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Neutral element for addition.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-neg"><a href="#val-neg" class="anchor"></a><code><span><span class="keyword">val</span> neg : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Inverse for addition: for all <code>u</code>, <code>add u (neg u) = zero</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mul"><a href="#val-mul" class="anchor"></a><code><span><span class="keyword">val</span> mul : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mul</code> will be only be called with values that are compatible with its monotonicity: its arguments can be two bounds with the same sign and kind (upper or lower), or two bounds with opposite signs and opposite kinds (upper or lower), but never two bounds with the same sign and opposite kinds or opposite signs and the same kind.</p><p>It is recommended to program defensively and raise an assertion failure if <code>mul</code> is ever called with two bounds of the same sign and opposite kinds or opposite signs and the same kind.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span><span class="keyword">val</span> pow : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>pow n x</code> raises <code>x</code> to the <code>n</code>-th power.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_arg</code> <p>if <code>n</code> is nonpositive.</p></li></ul></div></div></div></body></html>
